# Boost.Build support for the Xilinx SDK (XSDK).

import os ;
import path ;
import common ;
import print ;
import sequence ;
import errors ;
import assert ;

import toolset ;
import feature ;
import type ;
import "class" ;
import generators ;

if [ MATCH (--debug-configuration) : [ modules.peek : ARGV ] ]
{
  .debug-configuration = true ;
}

target-os-supported =
  elf
  freertos
  xilkernel
  ;

# @todo until all target-os supported in Boost.Build
for local t in $(target-os-supported)
{
  local target-os-values = [ feature.values <target-os> ] ;
  if ! $(t) in $(target-os-values)
  {
    feature.extend target-os : $(t) ;
  }
}

architecture-supported =
  arm
  microblaze
  ;

# @todo until all architecture supported in Boost.Build
for local t in $(architecture-supported)
{
  local architecture-values = [ feature.values <architecture> ] ;
  if ! $(t) in $(architecture-values)
  {
    feature.extend architecture : $(t) ;
  }
}

instruction-set-supported =
  # arm
  armv7-a
  armv7-r
  armv8-a
  armv8-r

  # microblaze
  mb-v6.00.a
  mb-v6.00.b
  ;

# @todo until all instruction-set supported in Boost.Build
for local t in $(instruction-set-supported)
{
  local instruction-set-values = [ feature.values <instruction-set> ] ;
  if ! $(t) in $(instruction-set-values)
  {
    feature.extend instruction-set : $(t) ;
  }
}

processor-supported =
  # arm
  cortex-a9
  cortex-a53
  cortex-r5

  # microblaze
  mb-v6.00.a
  mb-v6.00.b
  ;

# @todo this should be part of boost.build
feature.feature processor
  : # values
    $(processor-supported)
  : # attributes
    propagated optional
  ;

feature.feature processor-id : : optional free link-incompatible ;

feature.feature xsdk-template : : free ;
feature.feature xsdk-configuration : : optional free link-incompatible ;
feature.feature xsdk-library : : optional free ;

type.register XSCT : xsct ;

type.register XSCTRUN : xsctrun ;

type.register XSDKWS : xsdkws ;

type.register MSS : mss ;

type.register HDF : hdf ;
type.register BIT : bit ;
type.register TCL : tcl ;

rule init ( version ? : command * : options * )
{
  # Check that the host operating system is supported.  If it is not,
  # continue without configuring so we can still build targets that do
  # not need this toolset.
  if [ os.name ] = NT || [ os.name ] = CYGWIN || [ os.name ] = LINUX
  {
    command = [ common.get-invocation-command xsdk : xsct : $(command) ] ;

    if $(command)
    {
      local output-lines = [ SPLIT_BY_CHARACTERS [ SHELL "\"$(command)\" -eval \"puts [version]\"" ] : "\n" ] ;

      local detected-version-components = [ MATCH "xsct ([0-9][0-9][0-9][0-9]\\.[0-9])" : $(output-lines[1]) ] ;
      local detected-version = $(detected-version-components[1]) ;

      if ! $(detected-version)
      {
        errors.user-error "xsdk: no version detected" ;
      }

      if $(version)
      {
        if $(detected-version) != $(version)
        {
          errors.user-error "xsdk: detected version (" $(detected-version) ") does not match desired (" $(version) ")" ;
        }
      }

      if $(detected-version)
      {
        version = $(detected-version) ;
      }
    }
    else
    {
      errors.user-error "xsdk: xsct not found at" $(command) ;
    }

    root = [ common.get-absolute-tool-path $(command[-1]) ] ;
    root = [ path.make $(root:D) ] ;

    if $(.debug-configuration)
    {
      ECHO "xsdk: using xsdk" $(version) "at" $(root) ;

      ECHO "xsdk: available application templates" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -apps]\"" ] ;
      ECHO "xsdk: available operating systems" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -os]\"" ] ;
      ECHO "xsdk: available libraries" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -libs]\"" ] ;
      ECHO "xsdk: available drivers" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -drivers]\"" ] ;
    }

    toolset.flags xsdk .xsct $(condition) : $(root)/bin/xsct ;
  }
  else
  {
    ECHO "xsdk: warning: unsupported operating system" os.name ;
  }
}

rule root ( )
{
  return $(root) ;
}

class ws-generator : generator
{
  rule __init__ ( id composing ? : source-types + : target-types-and-names + : requirements * )
  {
    generator.__init__ $(id) $(composing) : $(source-types) : $(target-types-and-names) : $(requirements) ;
  }

  rule run ( project name ? : property-set : sources * )
  {
    # @todo cannot call from here
    # check-properties [ $(property-set).raw ] ;

    local r = [ generator.run $(project) $(name) : $(property-set) : $(sources) ] ;

    local ps ;
    local vts ;

    if [ class.is-a $(r[1]) : property-set ]
    {
      ps = $(r[1]) ;
      vts = $(r[2-]) ;
    }
    else
    {
      vts = $(r) ;
    }

    local ws-dir ;

    for local vt in $(vts)
    {
      if [ $(vt).type ] = XSDKWS
      {
        local p = [ $(vt).path ] ;
        local n = [ $(vt).name ] ;

        ws-dir = $(p)/$(n) ;
      }
    }

    local properties = [ $(ps).raw ] ;

    # add properties from createhw

    properties += <include>$(ws-dir)/hw ;

    local processor = [ $(property-set).get <processor> ] ;
    local instruction-set = [ $(property-set).get <instruction-set> ] ;
    local architecture = [ $(property-set).get <architecture> ] ;

    # @todo this cannot work due to toolset and usage-requirement
    # toolset = [ processor-to-toolset $(processor) ] ;
    # properties += <toolset>$(toolset) ;

    # @todo these should be done in gcc.jam really
    # @todo support specific processors better
    properties += <cflags>-march=$(instruction-set) ;
    properties += <cflags>-mtune=$(processor) ;
    switch $(processor)
    {
      case cortex-r5 : properties += <cflags>-mfpu=vfpv3-d16 ;
    }

    # add properties from createbsp

    for local vt in $(vts)
    {
      if [ type.is-derived [ $(vt).type ] LIB ]
      {
        local s = [ $(vt).search ] ;

        properties += <include>$(s:D)/include ;
      }
    }

    # add properties from createapp

    # @todo cannot call from here
    # local defines = [ processor-to-defines $(processor) ] ;
    local defines ;
    switch $(processor)
    {
      case cortex-r5 : defines += ARMR5 ;
    }

    properties += <define>$(defines) ;

    properties += <linkflags>"-T $(ws-dir)/app/src/lscript.ld" ;

    ps = [ property-set.create $(properties) ] ;

    return $(ps) $(vts) ;
  }

  rule generated-targets ( sources + : property-set : project name ? )
  {
    # @todo cannot call from here
    # check-properties [ $(property-set).raw ] ;

    local source = $(sources[0]) ;

    if ! $(name)
    {
      name = [ generator.determine-output-name $(source) ] ;
    }

    local virtual-targets ;

    local a = [ class.new action $(source) : xsdk.ws-generator : $(property-set) ] ;

    local t ;

    t = [ class.new file-target $(name) : XSDKWS : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    local build-dir = [ $(t).path ] ;
    local ws = [ $(t).name ] ;

    # targets generated by createhw

    # @todo do not generate the HDF target since it might be circular
    #t = [ class.new file-target $(ws)/hw/system : HDF : $(project) : $(a) ] ;
    #virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target $(ws)/hw/system : BIT : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target $(ws)/hw/psu_init : TCL : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target $(ws)/hw/psu_init : H : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    t = [ class.new file-target $(ws)/hw/psu_init : C : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    t = [ class.new file-target $(ws)/hw/psu_init_gpl : H : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    # @todo this duplicates whats in psu_init for some reason, which one is the right one?
    # t = [ class.new file-target $(ws)/hw/psu_init_gpl : C : $(project) : $(a)  ] ;
    # virtual-targets += [ virtual-target.register $(t) ] ;

    # targets generated by createbsp

    t = [ class.new file-target $(ws)/bsp/system : MSS : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    local properties = [ $(property-set).raw ] ;

    local shared ;
    if <link>shared in $(properties)
    {
      shared = true ;
    }

    local processor = [ feature.get-values <processor> : $(properties) ] ;
    # @todo this cannot be called from here
    # local xsdk-processor = [ processor-to-xsdk $(processor) ] ;
    local xsdk-processor ;
    switch $(processor)
    {
      case cortex-a9 : xsdk-processor = cortexa9 ;
      case cortex-a53 : xsdk-processor = cortexa53 ;
      case cortex-r5 : xsdk-processor = cortexr5 ;
    }
    local processor-id = [ feature.get-values <processor-id> : $(properties) ] ;
    processor-id ?= 0 ;

    t = [ class.new searched-lib-target xil : $(project) : $(shared) : $(build-dir)/$(ws)/bsp/psu_$(xsdk-processor)_$(processor-id)/lib : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    if <target-os>freertos in $(properties)
    {
      t = [ class.new searched-lib-target freertos : $(project) : $(shared) : $(build-dir)/$(ws)/bsp/psu_$(xsdk-processor)_$(processor-id)/lib : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    for local l in [ $(property-set).get <xsdk-library> ]
    {
      # @todo cannot be called from here
      # local translated-l = [ xsdk-library-to-library $(l) ] ;
      local translated-l = $(l) ;
      switch $(translated-l)
      {
        case libmetal : translated-l = metal ;
        case openamp : translated-l = open_amp ;
      }

      t = [ class.new searched-lib-target $(translated-l) : $(project) : $(shared) : $(build-dir)/$(ws)/bsp/psu_$(xsdk-processor)_$(processor-id)/lib : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    return $(virtual-targets) ;
  }
}

generators.register-standard xsdk.generate-build-and-run : HDF : XSCT TCL(%-run) ;
generators.register-standard xsdk.run-xsct : XSCT : XSCTRUN ;
generators.register [ class.new ws-generator xsdk.ws-generator : XSCTRUN : XSDKWS BIT H C TCL MSS LIB ] ;

# @todo these magically result in XSDKWS being dependent on the right stuff
toolset.flags xsdk.generate-build-and-run XSDK_CONFIGURATIONS <xsdk-configuration> ;
toolset.flags xsdk.generate-build-and-run XSDK_TEMPLATE <xsdk-template> ;
toolset.flags xsdk.generate-build-and-run XSDK_LIBRARIES <xsdk-library> ;
toolset.flags xsdk.generate-build-and-run XSDK_OS <target-os> ;
toolset.flags xsdk.generate-build-and-run XSDK_PROC <processor> ;
toolset.flags xsdk.generate-build-and-run XSDK_PROC_ID <processor-id> ;
toolset.flags xsdk.generate-build-and-run XSDK_LINK <link> ;
toolset.flags xsdk.generate-build-and-run XSDK_LINK <optimization> ;

rule generate-build-and-run ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 2 ;
  assert.equal [ sequence.length $(sources) ] : 1 ;

  generate-build $(targets[1]) : $(sources) : $(properties) ;
  generate-run $(targets[2]) : $(targets[1]) $(sources) : $(properties) ;
}

rule generate-build ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 1 ;

  check-properties $(properties) ;

  local target = $(targets[1]) ;
  local source = $(sources[1]) ;
  local ws-dir = [ on $(target) return $(LOCATE) ] ;
  local ws-name = $(target:G=) ;
  local ws = $(ws-dir)/$(ws-name:S=.xsdkws) ;

  local hdf = $(source:G=) ;

  local processor = [ feature.get-values <processor> : $(properties) ] ;
  local xsdk-processor = [ processor-to-xsdk $(processor) ] ;
  local processor-id = [ feature.get-values <processor-id> : $(properties) ] ;
  processor-id ?= 0 ;
  local target-os = [ feature.get-values <target-os> : $(properties) ] ;
  local xsdk-target-os = [ target-os-to-xsdk $(target-os) ] ;

  local xsdk-template = [ feature.get-values <xsdk-template> : $(properties) ] ;
  xsdk-template ?= "Empty Application" ;

  local lines ;

  # @todo check for errors

  # @todo delete the workspace if it exists
###  lines +=
###    "if {[file exists $(ws)]} then {"
###    "    puts \"error: $(ws) exists.\""
###    "    exit 1"
###    "}"
###  ;

  # set the workspace
  lines += "setws $(ws)" ;

  # create the hardware
  # @todo check for errors
  lines += "createhw -name hw -hwspec $(hdf)" ;

  # create and configure the bsp
  # @todo print out all available options nicely
  # @todo check for errors
  lines += "createbsp -name bsp -proc psu_$(xsdk-processor)_$(processor-id) -hwproject hw -os $(xsdk-target-os)" ;
  # @todo print out all available options for each library nicely
  for local l in [ feature.get-values <xsdk-library> : $(properties) ]
  {
    # @todo check for errors
    lines += "setlib -bsp bsp -lib $(l)" ;
  }
  # @todo print out all available options nicely
  for local c in [ feature.get-values <xsdk-configuration> : $(properties) ]
  {
    # @todo check for errors
    lines += "configbsp -bsp bsp $(c)" ;
  }

  lines += "updatemss -mss $(ws)/bsp/system.mss" ;
  lines += "regenbsp -bsp bsp" ;

  # create a dummy application for the linker file
  # @todo check for errors
  lines += "createapp -name app -app {$(xsdk-template)} -lang c -bsp bsp -proc psu_$(xsdk-processor)_$(processor-id) -hwproject hw -os $(xsdk-target-os)" ;

  # build the bsp (but not the application)
  # @todo check for errors
  lines += "projects -build -type bsp -name bsp" ;

  print.output $(target) ;
  print.text "#!/usr/bin/env xsct" : true ;
  print.text "# generated by xsdk.jam" ;
  print.lines $(lines) ;
  print.text "" ;
}

rule generate-run ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 2 ;

  check-properties $(properties) ;

  local target = $(targets[1]) ;
  local build-source = $(sources[1]) ;
  local hdf-source = $(sources[2]) ;

  local ws-dir = [ on $(build-source) return $(LOCATE) ] ;
  local ws-name = $(build-source:G=) ;
  local ws = $(ws-dir)/$(ws-name:S=.xsdkws) ;

  local fpga-name = $(hdf-source:B) ;

  # @todo use these below to configure
  local processor = [ feature.get-values <processor> : $(properties) ] ;
  local processor-id = [ feature.get-values <processor-id> : $(properties) ] ;
  processor-id ?= 0 ;

  local lines ;

  lines += "set xsdkroot [file normalize $(root)]" ;

  # @todo check for errors

  # set the workspace
  lines +=
    "if {$argc != 1} then {"
    "    puts \"usage: $argv0 <program>\""
    "    exit 1"
    "}"
    ;

  lines +=
    "set ws [file normalize $(ws)]"

    "set hdf [file normalize [file join $ws system.hdf]]"
    "set bit [file normalize [file join $ws $(fpga-name:S=.bit)]]]"

    "set jtag_cable_name \"*\""

    "if {! [file exists $ws]} {"
    "    puts \"error: workspace $ws does not exist\""
    "    exit 1"
    "}"
    "setws -switch $ws"

    "connect"

    "source [file normalize [file join $xsdkroot scripts sdk util zynqmp_utils.tcl]]"

    # @todo below is RPU-specific, not easy to generalize without knowing a lot
    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "rst -system"
    "after 3000"

    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "reset_apu"

    "targets -set -nocase -filter {name =~ \"RPU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "clear_rpu_reset"
    "enable_split_mode"

    "targets -set -filter {jtag_cable_name =~ $jtag_cable_name && level==0} -index 0"
    "fpga -file $bit"

    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "loadhw -hw $hdf -mem-ranges [list {  0x80000000   0xbfffffff} { 0x400000000  0x5ffffffff} {0x1000000000 0x7fffffffff}]"

    "configparams force-mem-access 1"
    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"

    "source [file join $ws hw psu_init.tcl]"
    "after 3000"
    "psu_init"
    "source [file normalize [file join $xsdkroot scripts sdk util fsbl.tcl]]"
    "after 1000"
    "psu_ps_pl_isolation_removal"
    "after 1000"
    "psu_ps_pl_reset_config"
    "catch {psu_protection}"

    "targets -set -nocase -filter {name =~ \"*R5*0\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "rst -processor"
    "catch {XFsbl_TcmEccInit R5_0}"

    "dow $program"

    "bpadd -addr &main"

    "configparams force-mem-access 0"

    "con"
  ;

  print.output $(target) ;
  print.text "#!/usr/bin/env xsct" : true ;
  print.text "# generated by xsdk.jam" ;
  print.lines $(lines) ;
  print.text "" ;
}

TOUCH = [ common.file-touch-command ] ;

actions run-xsct
{
  "$(.xsct)" "$(>[1])" && $(TOUCH) "$(<[1])"
}

rule ws-generator ( targets + : sources + : properties * )
{
  # assert.equal [ sequence.length $(targets) ] : 2 ;
  assert.equal [ sequence.length $(sources) ] : 1 ;

  check-properties $(properties) ;
}

# Check that the given properties are supported by this module and
# report an error if not.
#
local rule check-properties ( properties * )
{
  if ! [ feature.get-values <target-os> : $(properties) ]
  {
    errors.user-error "<target-os> is empty, support values are [" '$(target-os-supported)' "]" ;
  }
  if ! [ feature.get-values <processor> : $(properties) ]
  {
    errors.user-error "<processor> is empty, support values are [" '$(processor-supported)' "]" ;
  }

  check-feature-supported target-os : $(properties) ;
  check-feature-supported processor : $(properties) ;
}

# Check that the given properties are supported by this module for
# feature <name> and report an error if not.
#
local rule check-feature-supported ( name : properties * )
{
  local f = [ feature.get-values <$(name)> : $(properties) ] ;
  if ! $(f) in $($(name)-supported)
  {
    errors.user-error '$(f)' "is not a supported value of <$(name)>, supported values are [" '$($(name)-supported)' "]" ;
  }
}

local rule target-os-to-xsdk ( value )
{
  assert.in $(value) : [ feature.values <target-os> ] ;

  local tmp ;
  switch $(value)
  {
    case elf : tmp = standalone ;
    case freertos : tmp = freertos10_xilinx ;
    case xilkernel : tmp = xilkernel ;
  }

  assert.variable-not-empty tmp ;

  return $(tmp) ;
}

local rule processor-to-toolset ( value )
{
  assert.in $(value) : [ feature.values <processor> ] ;

  local tmp ;
  switch $(value)
  {
    case cortex-r5 : tmp = gcc-7xilinxarmr5 ;
    case cortex-a53 : tmp = gcc-7xilinxaarch64 ;
  }

  assert.variable-not-empty tmp ;

  return $(tmp) ;
}

local rule processor-to-xsdk ( value )
{
  assert.in $(value) : [ feature.values <processor> ] ;

  local tmp ;
  switch $(value)
  {
    case cortex-a9 : tmp = cortexa9 ;
    case cortex-a53 : tmp = cortexa53 ;
    case cortex-r5 : tmp = cortexr5 ;
  }

  assert.variable-not-empty tmp ;

  return $(tmp) ;
}

local rule processor-to-defines ( value )
{
  assert.in $(value) : [ feature.values <processor> ] ;

  local tmp ;
  switch $(value)
  {
    case cortex-r5 : tmp += ARMR5 ;
  }

  return $(tmp) ;
}

local rule xsdk-library-to-library ( value )
{
  local tmp = $(value) ;
  switch $(tmp)
  {
    case libmetal : tmp = metal ;
    case openamp : tmp = open_amp ;
  }

  assert.variable-not-empty tmp ;

  return $(tmp) ;
}
