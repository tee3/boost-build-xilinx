# Boost.Build support for the Xilinx SDK (XSDK).

# @todo need to generate an app to get the linker script

import print ;
import errors ;

import toolset ;
import project ;
import feature ;
import targets ;
import type ;
import "class" ;
import common ;
import generators ;

import os ;

if [ MATCH (--debug-configuration) : [ modules.peek : ARGV ] ]
{
  .debug-configuration = true ;
}

feature.extend target-os :
  freertos
  xilsystem
  ;

feature.extend instruction-set :
  armv8
  ;

feature.feature xsdk-template : : optional free link-incompatible ;
feature.feature xsdk-library : : optional free ;
feature.feature xsdk-configuration : : optional free link-incompatible ;
feature.feature xsdk-language : c c++ : propagated link-incompatible ;
feature.set-default xsdk-language : c++ ;
feature.feature xsdk-processor-id : 0 1 2 3 : propagated link-incompatible ;
feature.set-default xsdk-processor-id : 0 ;

type.register XSDKWS : xsdkws ;

type.register XSCT : xsct ;

type.register MSS : mss ;

type.register HDF : hdf ;
type.register BIT : bit ;
type.register TCL : tcl ;

rule init ( version ? : command * : options * )
{
  # Check that the host operating system is supported.  If it is not,
  # continue without configuring so we can still build targets that do
  # not need this toolset.
  if [ os.name ] = NT || [ os.name ] = CYGWIN || [ os.name ] = LINUX
  {
    command = [ common.get-invocation-command xsdk : xsct : $(command) ] ;

    if $(command)
    {
      local output-lines = [ SPLIT_BY_CHARACTERS [ SHELL "\"$(command)\" -eval 'puts [version]'" ] : "\n" ] ;

      local detected-version-components = [ MATCH "xsct ([0-9][0-9][0-9][0-9]\\.[0-9])" : $(output-lines[1]) ] ;
      local detected-version = $(detected-version-components[1]) ;

      if ! $(detected-version)
      {
        errors.user-error "xsdk: no version detected" ;
      }

      if $(version)
      {
        if $(detected-version) != $(version)
        {
          errors.user-error "xsdk: detected version (" $(detected-version) ") does not match desired (" $(version) ")" ;
        }
      }

      if $(detected-version)
      {
        version = $(detected-version) ;
      }
    }
    else
    {
      errors.user-error "xsdk: xsct not found at" $(command) ;
    }

    root = [ common.get-absolute-tool-path $(command[-1]) ] ;
    root = $(root:P) ;

    if $(.debug-configuration)
    {
      ECHO "xsdk: using xsdk" $(version) "at" $(root) ;
    }

    toolset.flags xsdk .bin $(condition) : $(root)/bin ;

    # @todo this is where the compilers are on Linxu
    #using gcc : armr5 : $(root)/gnu/armr5/lin/gcc-arm-non-eabi/bin/g++ ;
    #using gcc : aarch64 : $(root)/gnu/aarch64/lin/gcc-arm-non-eabi/bin/g++ ;
  }
  else
  {
    ECHO "xsdk: warning: unsupported operating system" os.name ;
  }
}

class ws-generator : generator
{
  rule __init__ ( id composing ? : source-types + : target-types-and-names + : requirements * )
  {
    generator.__init__ $(id) $(composing) : $(source-types) : $(target-types-and-names) : $(requirements) ;
  }

  rule run ( project name ? : property-set : sources * )
  {
    echo ws-generator run --------------------- ;
    echo $(project) ;
    echo --------------------- ;
    echo $(name) ;
    echo --------------------- ;
    echo $(property-set) ;
    echo [ $(property-set).raw ] ;
    echo --------------------- ;
    echo $(sources) ;
    for local s in $(sources)
    {
      echo [ $(s).name ] ;
    }
    echo --------------------- ;

    local r = [ generator.run $(project) $(name) : $(property-set) : $(sources) ] ;

    local ps ;
    local vts ;

    if [ class.is-a $(r[1]) : property-set ]
    {
      ps = $(r[1]) ;
      vts = $(r[2-]) ;
    }
    else
    {
      vts = $(r) ;
    }

    local ws-dir ;

    for local vt in $(vts)
    {
      if [ $(vt).type ] = XSDKWS
      {
        local p = [ $(vt).path ] ;
        local n = [ $(vt).name ] ;

        ws-dir = $(p)/$(n) ;
      }
    }

    # add properties from createhw
    ps = [ $(ps).add-raw <include>$(ws-dir)/hw ] ;

    # add properties from createbsp
    for local vt in $(vts)
    {
      if [ type.is-derived [ $(vt).type ] LIB ]
      {
        local s = [ $(vt).search ] ;

        ps = [ $(ps).add-raw <include>$(s:D)/include ] ;
      }
    }

    # add properties from createapp
    ps = [ $(ps).add-raw <linkflags>"-T $(ws-dir)/app/src/lscript.ld" ] ;

    echo "properties: " [ $(ps).raw ] ;
    echo "virtual-targets:" ;
    for local vt in $(vts)
    {
      echo [ $(vt).name ] ;
    }

    return $(ps) $(vts) ;
  }

  rule generated-targets ( sources + : property-set : project name ? )
  {
    echo ws-generator generated-targets --------------------- ;
    echo $(project) ;
    echo --------------------- ;
    echo $(name) ;
    echo --------------------- ;
    echo $(property-set) ;
    echo [ $(property-set).raw ] ;
    echo --------------------- ;
    echo $(sources) ;
    for local s in $(sources)
    {
      echo [ $(s).name ] ;
    }
    echo --------------------- ;

    local source = $(sources[0]) ;

    if ! $(name)
    {
      name = [ generator.determine-output-name $(source) ] ;
    }

    echo "name = $(name)" ;

    local a = [ class.new action $(source) : xsdk.ws-generator : $(property-set) ] ;

    local virtual-targets ;
    local t ;

    t = [ class.new file-target $(name) : XSDKWS : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    local build-dir = [ $(t).path ] ;
    local xsdkws-name = [ $(t).name ] ;

    t = [ class.new file-target $(name) : XSCT : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    local ws-dir = $(build-dir)/$(xsdkws-name) ;

    local hw-dir = $(ws-dir)/hw ;
    local bsp-dir = $(ws-dir)/bsp ;
    local app-dir = $(ws-dir)/app ;

    # targets generated by createhw

    # @todo do not generate the HDF target since it might be circular
    #t = [ class.new file-target system : HDF : $(project) : $(a) : $(hw-dir) ] ;
    #virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target system : BIT : $(project) : $(a) : $(hw-dir) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target psu_init : TCL : $(project) : $(a) : $(hw-dir) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target psu_init : H : $(project) : $(a) : $(hw-dir) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    t = [ class.new file-target psu_init : C : $(project) : $(a) : $(hw-dir) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    # @todo this duplicates whats in psu_init for some reason
    # t = [ class.new file-target psu_init_gpl : H : $(project) : $(a) : $(hw-dir) ] ;
    # virtual-targets += [ virtual-target.register $(t) ] ;
    # t = [ class.new file-target psu_init_gpl : C : $(project) : $(a) : $(hw-dir) ] ;
    # virtual-targets += [ virtual-target.register $(t) ] ;

    # targets generated by createbsp

    t = [ class.new file-target system : MSS : $(project) : $(a) : $(bsp-dir) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    local properties = [ $(property-set).raw ] ;

    local shared ;
    if <link>shared in $(properties)
    {
      shared = true ;
    }

    local processor ;
    if <instruction-set>armv7 in $(properties)
    {
      processor = cortexr5 ;
    }
    else if <instruction-set>armv8 in $(properties)
    {
      processor = cortexa53 ;
    }
    else
    {
      #errors.error "unsupported processor" ;
      echo "error: unsupported processor" ;
    }

    # @todo more
    local processor-id ;
    if <xsdk-processor-id>0 in $(properties)
    {
      processor-id = 0 ;
    }
    else
    {
      #errors.error "unsupported processor id" ;
      echo "error: unsupported processor id" ;
    }

    # @todo use <library> (or others) to find the libraries by searching the list, get list from xsct repo?
    t = [ class.new searched-lib-target xil : $(project) : $(shared) : $(bsp-dir)/psu_$(processor)_$(processor-id)/lib : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    for local l in [ $(property-set).get <xsdk-library> ]
    {
      t = [ class.new searched-lib-target $(l) : $(project) : $(shared) : $(bsp-dir)/psu_$(processor)_$(processor-id)/lib : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    if <target-os>freertos in $(properties)
    {
      t = [ class.new searched-lib-target freertos : $(project) : $(shared) : $(bsp-dir)/psu_$(processor)_$(processor-id)/lib : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    echo "properties: " [ $(property-set).raw ] ;
    echo "virtual-targets:" ;
    for local vt in $(virtual-targets)
    {
      echo [ $(vt).name ] ;
    }

    return $(virtual-targets) ;
  }
}

# @todo could also call out the source files?
# generators.register [ class.new ws-generator xsdk.ws-generator : HDF : XSDKWS XSCT HDF BIT TCL MSS LIB ] ;
generators.register [ class.new ws-generator xsdk.ws-generator : HDF : XSDKWS XSCT BIT H C TCL MSS LIB ] ;

toolset.flags xsdk.ws-generator XSDK_TEMPLATE <xsdk-template> ;

toolset.flags xsdk.ws-generator XSDK_LIBRARIES <xsdk-library> ;

toolset.flags xsdk.ws-generator XSDK_CONFIGURATIONS <xsdk-configuration> ;

toolset.flags xsdk.ws-generator XSDK_LANGUAGE <xsdk-language>c : "-lang c" ;
toolset.flags xsdk.ws-generator XSDK_LANGUAGE <xsdk-language>c++ : "-lang c++" ;

toolset.flags xsdk.ws-generator XSDK_OS <target-os>elf : "-os standalone" ;
toolset.flags xsdk.ws-generator XSDK_OS <target-os>freertos : "-os freertos10_xilinx" ;
toolset.flags xsdk.ws-generator XSDK_OS <target-os>xilsystem : "-os xilsystem" ;

toolset.flags xsdk.ws-generator XSDK_PROC <instruction-set>armv8 : cortexa53 ;
toolset.flags xsdk.ws-generator XSDK_PROC <instruction-set>armv7 : cortexr5 ;

toolset.flags xsdk.ws-generator XSDK_PROC_ID <xsdk-processor-id>0 : 0 ;
toolset.flags xsdk.ws-generator XSDK_PROC_ID <xsdk-processor-id>1 : 1 ;
toolset.flags xsdk.ws-generator XSDK_PROC_ID <xsdk-processor-id>2 : 2 ;
toolset.flags xsdk.ws-generator XSDK_PROC_ID <xsdk-processor-id>3 : 3 ;

toolset.flags xsdk.ws-generator XSDK_LINK <link>shared : configbsp-pass-shared ;
toolset.flags xsdk.ws-generator XSDK_LINK <link>static : configbsp-pass-static ;

# @todo working out if this is the right way
# generates the tcl script to be run by the action
rule ws-generator ( targets + : sources + : properties * )
{
  echo ws-generator rule ;
  echo ------------------- ;
  echo $(targets) ;
  echo ------------------- ;
  echo $(sources) ;
  echo ------------------- ;
  echo $(properties) ;
  echo ------------------- ;

  local ws-dir = [ on $(targets[1]) return $(LOCATE) ] ;

  local ws = $(ws-dir)/$(targets[1]:G=) ;

  local hwspec = $(sources[1]:G=) ;

  local shared ;
  if <link>shared in $(properties)
  {
    shared = true ;
  }

  local processor ;
  if <instruction-set>armv7 in $(properties)
  {
    processor = cortexr5 ;
  }
  else if <instruction-set>armv8 in $(properties)
  {
    processor = cortexa53 ;
  }
  else
  {
    #errors.error "unsupported processor" ;
    echo "error: unsupported processor" ;
  }

  # @todo more
  local processor-id ;
  if <xsdk-processor-id>0 in $(properties)
  {
    processor-id = 0 ;
  }
  else
  {
    #errors.error "unsupported processor id" ;
    echo "error: unsupported processor id" ;
  }

  local lines =
    "#!/usr/bin/env xsct"
    "# DO NOT MODIFY - generated by Boost.Build xsdk.jam"
    ""
    "if {$argc != 1} then {"
    "    exit 1"
    "}"
    "setws $(ws)"
    ""
    "createhw -name hw -hwspec $(hwspec)"
    ""
    "createbsp -name bsp -proc psu_$(processor)_$(processor-id) -hwproject hw $(XSDK_OS)"
    ;

  print.output $(targets[2]) ;
  print.text $(lines) : true ;
}

actions ws-generator
{
  echo -------------------
  pwd
  echo -------------------
  # $(>)
  echo -------------------
  # $(<)
  echo -------------------
  # $(XSDK_TEMPLATE)
  # $(XSDK_LIBRARIES)
  # $(XSDK_CONFIGURATIONS)
  # $(XSDK_LANGUAGE)
  # $(XSDK_OS)
  # $(XSDK_PROC)
  # $(XSDK_PROC_ID)
  # $(XSDK_LINK)
  echo -------------------
  echo "setws $(<[1])" > $(<[1]:D)/$(<[1]:D=).tcl
  echo "" $(<[1]:D)/$(<[1]:D=).tcl
  echo "createhw -name hw -hwspec $(>)" >> $(<[1]:D)/$(<[1]:D=).tcl
  echo "" $(<[1]:D)/$(<[1]:D=).tcl
  echo "createbsp -name bsp -proc psu_$(XSDK_PROC)_$(XSDK_PROC_ID) -hwproject hw $(XSDK_OS)" >> $(<[1]:D)/$(<[1]:D=).tcl
  # @todo not portable
  # @todo figure out how to expand this right
  for l in $(XSDK_LIBRARIES) ; do
    echo "setlib -bsp bsp -lib ${l}" >> $(<[1]:D)/$(<[1]:D=).tcl
  done
  # @todo not portable
  # @todo figure out how to expand this right
  for c in "$(XSDK_CONFIGURATIONS)" ; do
    echo "configbsp -bsp bsp ${c}" >> $(<[1]:D)/$(<[1]:D=).tcl
  done
  echo "updatemss -mss $(<[1])/bsp/system.mss" >> $(<[1]:D)/$(<[1]:D=).tcl
  echo "regenbsp -bsp bsp" >> $(<[1]:D)/$(<[1]:D=).tcl
  echo "projects -build -type bsp -name bsp" >> $(<[1]:D)/$(<[1]:D=).tcl
  echo "" $(<[1]:D)/$(<[1]:D=).tcl
  #echo "createapp -name app -app {$(XSDK_TEMPLATE)} $(XSDK_LANGUAGE) -bsp bsp -proc psu_$(XSDK_PROC)_$(XSDK_PROC_ID) -hwproject hw $(XSDK_OS)" >> $(<[1]:D)/$(<[1]:D=).tcl
  echo "createapp -name app -app {} $(XSDK_LANGUAGE) -bsp bsp -proc psu_$(XSDK_PROC)_$(XSDK_PROC_ID) -hwproject hw $(XSDK_OS)" >> $(<[1]:D)/$(<[1]:D=).tcl
  echo "" $(<[1]:D)/$(<[1]:D=).tcl
  # @todo print out all available options
  echo running the following script -------------------
  cat $(<[1]:D)/$(<[1]:D=).tcl
  $(.bin)/xsct $(<[1]:D)/$(<[1]:D=).tcl > $(<[1]:D)/$(<[1]:D=).log
  cat $(<[1]:D)/$(<[1]:D=).log
  echo -------------------
}
