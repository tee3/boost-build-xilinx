# Copyright 2019 Thomas Brown
# Distributed under the Boost Software License, Version 1.0. (See
# accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)
#
# Boost.Build support for the Xilinx SDK (XSDK).

#| tag::doc[]

= Configuration

[source, jam]
----
import xsdk ;
----

The XSDK tool must be configured as any other Boost.Build tool.  The
tool will automatically detect the location and version of the tool.

[source, jam]
----
using xsdk ;
----

The desired version can be specified.

[source, jam]
----
using xsdk : 2018.3 ;
----

The location can also be specified both with and without a desired
version.

[source, jam]
----
using xsdk : : /opt/Xilinx/SDK/2018.3 ;
----

Note that running with the `--debug-configuration` option to
Boost.Build will print the XSDK location and version as well as the
application templates, operating systems, libraries, and drivers
supported by the version of the tool configured.

= Main Target

This project will add one main target type named `xsdkws`.

[source, jam]
----
xsdkws ( name : sources + : requirements * : default-build * : usage-requirements * )
----

This target will place an application named `app`, a board-support
packaged named `bsp`, and a hardware definition named `hw` within a
workspace named as defined in the rule, `$(name)`, and provide
`usage-requirements` to users of the named target.

This target will also create several supporting XSCT scripts in the
build directory.

The `print.tcl` script will print out all the available configuration
options for the XSDK Workspace.  This can be useful when developing
the configuration for a project.

The `run.tcl` script take the any compatible program file as an
argument and will run the program.  This script can be used with the
Boost.Build `testing` module as a `<testing.launcher>`.

This target works by creating and running an XSCT script containing
`xsct` commands with values translated from Boost.Build features such
as `<instruction-set>`, `<target-os>`, and others.  Some
representative examples of those `xsct` commands are below.

Create the workspace (`$(build-dir)/$(name).xsdkws`) from the
properties.

[source, tcl]
----
setws $(build-dir)/$(name).xsdkws
----

Generate the hardware definition (`hw`) from the hardware definition
file specified in `$(source)`.

[source, tcl]
----
createhw -name hw -hwspec $(source)
----

Generate and build a board-support package (`bsp`) from the hardware
definition (`hw`), standard Boost.Build features, and free-form
configuration options.

[source, tcl]
----
createbsp -name bsp -proc $(xsdk-instruction-set) -hwproject hw -os $(xsdk-os)

configbsp -bsp bsp sleep_timer psu_ttc_3

updatemss -mss  $ws/bsp/system.mss
regenbsp -bsp bsp

projects -build -type bsp -name bsp
----

Generate and build an application (`app`) along with some options
required to properly build an application.  This defaults to "Empty
Application" if `<xsdk-template>` is not defined.  Neither the
application template nor the application language is required, but can
sometimes be useful to generate a program that can be used as the
basis of your program.

For example, if `<target-os>` is `elf`, the script generated will be
something like the following.

[source, tcl]
----
createapp -name app       -app {$(xsdk-template)}  -lang c -bsp bsp -proc $(xsdk-processor-prefix)_$(xsdk-instruction-set)_$(xsdk-processor-id) -hwproject hw -os $(xsdk-os)

----

= Suported FPGA

* Zynq UltraScale+ MPSoC
* Zynq 7000 SoC

= Toolsets

This module supports any `gcc` toolset.  The user is responsible for
configuring the desired toolset for each processor.

Note that in order to choose the correct toolset, the toolset should
be made conditional on the `instruction-set` in the build system.
One approach for doing this would be to set project requirements in
the Jamroot.  This is required because the `toolset` feature cannot
set in `usage-requirements`.

The example below shows the configuration of the toolsets delivered
with the Xilinx SDK for each different processor supported by the
Xilinx SDK if the Xilinx SDK is installed.  If the Xilinx SDK is not
installed, it uses another third-party toolset.  Note that there is
nothing special about the name of the toolset, it is defined by the
user.

.`project-config.jam`
[source, jam]
----
import xsdk ;

project project-config
  : requirements
    <instruction-set>cortex-a9:<toolset>gcc-xsdkaarch32
    <instruction-set>cortex-a9+vfpv3:<toolset>gcc-xsdkaarch32
    <instruction-set>cortex-a53:<toolset>gcc-xsdkaarch64
    <instruction-set>cortex-r5:<toolset>gcc-xsdkarmr5
    <instruction-set>cortex-r5+vfpv3-d16:<toolset>gcc-xsdkarmr5
    <instruction-set>microblaze:<toolset>gcc-xsdkmicroblaze
  ;

using xsdk ;

local xsdk-root = [ xsdk.root ] ;

if $(xsdk-root)
{
  using gcc : xsdkaarch32 : $(xsdk-root)/gnu/aarch32/lin/gcc-arm-none-eabi/bin/arm-none-eabi-g++ ;
  using gcc : xsdkaarch64 : $(xsdk-root)/gnu/aarch64/lin/aarch64-none/bin/aarch64-none-elf-g++ ;
  using gcc : xsdkarmr5 : $(xsdk-root)/gnu/armr5/lin/gcc-arm-none-eabi/bin/armr5-none-eabi-g++ ;
  using gcc : xsdkmicroblaze : $(xsdk-root)/gnu/microblaze/lin/bin/microblaze-xilinx-elf-g++ ;
}
else
{
  using gcc : xsdkaarch32 : /usr/local/arm/gcc-arm-none-eabi-7-2018-q2-update/bin/arm-none-eabi-g++ ;
  using gcc : xsdkaarch64 : /usr/local/arm/gcc-arm-none-eabi-7-2018-q2-update/bin/arm-none-eabi-g++ ;
  using gcc : xsdkarmr5 : /usr/local/arm/gcc-arm-none-eabi-7-2018-q2-update/bin/arm-none-eabi-g++ ;
  # using gcc : xsdkmicroblaze : $(xsdk-root)/gnu/microblaze/lin/bin/microblaze-xilinx-elf-g++ ;
}
----

= Boost.Build Features

The following Boost.Build features are used to configure the XSDK.
Workspace.

If Boost.Build does not support a required value for a feature, the
`xsdk` tool will extend the feature with the additional values.

== `<target-os>` - the target operating system

* `elf` - The `standalone` Xilinx operating system.
* `freertos` - The FreeRTOS operating system for Zynq systems.
* `xilkernel` - The Xilinx kernel for Microblaze.

== `<architecture>` - the architecture

The architecture definition file defines which architectures are
available in a particular design.  The architectures supported by the
XSDK are shown below.

* `arm` - ARM
* `microblaze` - Microblaze

== `<instruction-set>` - the instruction set or processor

The hardware definition file defines which processors are available in
a particular design.  The processors supported by the XSDK are shown
below.

* `cortex-a9` - Cortex-A9
* `cortex-a9+vfpv3` - Cortex-A9 (vfpv3 FPU)
* `cortex-a53` - Cortex-A53
* `cortex-r5` - Cortex-R5
* `cortex-r5+vfpv3-d16` - Cortex-R5 (vfpv3-d16 FPU)
* `microblaze` - Microblaze

= XSDK-related Features

Boost.Build will generally configure the board-support package given
Boost.Build features.  These features can be overridden using the
following toolset flags.

== `xsdk-template`

This feature indicates the application template used to generate the
application.  The application provides a linker script that can be
used by programs built with the XSDK Workspace and can be found on the
library search path.

The resulting files can be used to create or update the actual
application code, but are not used when generating programs from the
XSDK Workspace.

This defaults to an empty application.

== `xsdk-configuration`

This feature provides information for configuring a board-support
package.  A configuration is a string added to the end of the call to
`configbsp`.

The system will generate the following for each
`<xsdk-configuration>STRING`.

[source, tcl]
----
configbps -bsp bsp STRING
----

== `xsdk-library`

This feature adds Xilinx libraries to the board-support package.
These are the library names as described in the XSDK documentation.

== `xsdk-processor-prefix`

This should be auto-detected by the system.

== `xsdk-processor-id`

This feature assigns the application to run on a particular processor
on the SoC, defaulting to 0.

== `xsdk-fpga`

This feature indicates the Xilinx FPGA.

* xczu6eg
* xczu7eg

This defaults to an xczu7eg.

|# # end::doc[]

import os ;
import path ;
import common ;
import print ;
import regex ;
import sequence ;
import errors ;
import assert ;

import toolset ;
import feature ;
import type ;
import "class" ;
import generators ;
import property-set ;

if [ MATCH (--debug-configuration) : [ modules.peek : ARGV ] ]
{
  .debug-configuration = true ;
}

feature.feature xsdk-template : : free ;
feature.feature xsdk-configuration : : free link-incompatible ;
feature.feature xsdk-library : : free link-incompatible ;
feature.feature xsdk-processor-prefix : : free ;
feature.feature xsdk-processor-id : 0 1 2 3 : link-incompatible ;
feature.set-default xsdk-processor-id : 0 ;

feature.feature xsdk-fpga
  :
    xczu6eg
    xczu7eg
  :
    propagated link-incompatible symmetric
  ;
feature.set-default xsdk-fpga : xczu7eg ;

feature.feature xsdk-os
  : # values
    standalone
    freertos10_xilinx
    xilkernel
  : # attributes
    propagated optional
  ;

# @todo until all target-os supported in Boost.Build
# @todo xilkernel only for microblaze, freertos only zynq
local target-os-supported =
  elf
  freertos
  xilkernel
  ;
for local t in $(target-os-supported)
{
  local target-os-values = [ feature.values <target-os> ] ;
  if ! $(t) in $(target-os-values)
  {
    ECHO "xsdk:warning: <target-os>$(t) is not supported in Boost.Build." ;

    feature.extend target-os : $(t) ;
  }
}

feature.feature xsdk-instruction-set
  : # values
    # arm
    cortexa9
    cortexa53
    cortexr5

    # xilinx
    microblaze
  : # attributes
    propagated optional
  ;

# @todo until all architecture supported in Boost.Build
local architecture-supported =
  arm
  microblaze
  ;
for local t in $(architecture-supported)
{
  local architecture-values = [ feature.values <architecture> ] ;
  if ! $(t) in $(architecture-values)
  {
    ECHO "xsdk:warning: <architecture>$(t) is not supported in Boost.Build." ;

    feature.extend architecture : $(t) ;
  }
}

# @todo until all instruction-set supported in Boost.Build
local instruction-set-supported =
  cortex-a9
  cortex-a9+vfpv3
  cortex-a53
  cortex-r5
  cortex-r5+vfpv3-d16

  microblaze
  ;
for local t in $(instruction-set-supported)
{
  local instruction-set-values = [ feature.values <instruction-set> ] ;
  if ! $(t) in $(instruction-set-values)
  {
    ECHO "xsdk:warning: <instruction-set>$(t) is not supported in Boost.Build." ;

    feature.extend instruction-set : $(t) ;

    switch $(t)
    {
      case cortex-a9 :
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9:<cflags>-mcpu=cortex-a9 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9:<cflags>-mcpu=cortex-a9 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9:<linkflags>-mcpu=cortex-a9 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9:<linkflags>-mcpu=cortex-a9 ;
      case cortex-a9+vfpv3 :
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9+vfpv3:<cflags>-mcpu=cortex-a9 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9+vfpv3:<cflags>-mcpu=cortex-a9 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9+vfpv3:<linkflags>-mcpu=cortex-a9 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9+vfpv3:<linkflags>-mcpu=cortex-a9 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9+vfpv3:<cflags>-mfpu=vfpv3 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9+vfpv3:<cflags>-mfpu=vfpv3 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9+vfpv3:<linkflags>-mfpu=vfpv3 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9+vfpv3:<linkflags>-mfpu=vfpv3 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9+vfpv3:<cflags>-mfloat-abi=hard ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9+vfpv3:<cflags>-mfloat-abi=hard ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a9+vfpv3:<linkflags>-mfloat-abi=hard ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a9+vfpv3:<linkflags>-mfloat-abi=hard ;
      case cortex-a53 :
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a53:<cflags>-mcpu=cortex-a53 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a53:<cflags>-mcpu=cortex-a53 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-a53:<linkflags>-mcpu=cortex-a53 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-a53:<linkflags>-mcpu=cortex-a53 ;
      case cortex-r5 :
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-r5:<cflags>-mcpu=cortex-r5 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-r5:<cflags>-mcpu=cortex-r5 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-r5:<linkflags>-mcpu=cortex-r5 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-r5:<linkflags>-mcpu=cortex-r5 ;
      case cortex-r5+vfpv3-d16 :
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mcpu=cortex-r5 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mcpu=cortex-r5 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mcpu=cortex-r5 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mcpu=cortex-r5 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mfpu=vfpv3-d16 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mfpu=vfpv3-d16 ;
        toolset.add-requirements <toolset>gcc,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mfpu=vfpv3-d16 ;
        toolset.add-requirements <toolset>gcc,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mfpu=vfpv3-d16 ;
        toolset.add-requirements <toolset>gcc,<target-os>elf,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mfloat-abi=hard ;
        toolset.add-requirements <toolset>gcc,<target-os>elf,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mfloat-abi=hard ;
        toolset.add-requirements <toolset>gcc,<target-os>elf,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mfloat-abi=hard ;
        toolset.add-requirements <toolset>gcc,<target-os>elf,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mfloat-abi=hard ;
        toolset.add-requirements <toolset>gcc,<target-os>freertos,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mfloat-abi=softfp ;
        toolset.add-requirements <toolset>gcc,<target-os>freertos,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<cflags>-mfloat-abi=softfp ;
        toolset.add-requirements <toolset>gcc,<target-os>freertos,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mfloat-abi=softfp ;
        toolset.add-requirements <toolset>gcc,<target-os>freertos,<architecture>arm,<instruction-set>cortex-r5+vfpv3-d16:<linkflags>-mfloat-abi=softfp ;
    }
  }
}

type.register XSDKWS : xsdkws ;

type.register HDF : hdf ;

type.register XSCT : xsct ;
type.register XSCTRUN : xsctrun ;

type.register MSS : mss ;
type.register BIT : bit ;
type.register TCL : tcl ;

rule init ( version ? : command * : options * )
{
  # Check that the host operating system is supported.  If it is not,
  # continue without configuring so we can still build targets that do
  # not need this toolset.
  if [ os.name ] = NT || [ os.name ] = CYGWIN || [ os.name ] = LINUX
  {
    command = [ common.get-invocation-command xsdk : xsct : $(command) ] ;

    if $(command)
    {
      local output-lines = [ SPLIT_BY_CHARACTERS [ SHELL "\"$(command)\" -nodisp -eval \"puts [version]\"" ] : "\n" ] ;

      local detected-version-components = [ MATCH "xsct ([0-9][0-9][0-9][0-9]\\.[0-9])" : $(output-lines) ] ;
      local detected-version = $(detected-version-components[1]) ;

      if ! $(detected-version)
      {
        errors.user-error "xsdk: no version detected" ;
      }

      if $(version)
      {
        if $(detected-version) != $(version)
        {
          errors.user-error "xsdk: detected version (" $(detected-version) ") does not match desired (" $(version) ")" ;
        }
      }

      if $(detected-version)
      {
        version = $(detected-version) ;
      }
    }
    else
    {
      errors.user-error "xsdk: xsct not found at" $(command) ;
    }

    .version = $(version) ;
    .root = [ common.get-absolute-tool-path $(command[-1]) ] ;
    .root = [ path.make $(.root:D) ] ;

    if $(.debug-configuration)
    {
      ECHO "xsdk: using xsdk" $(version) "at" $(.root) ;

      ECHO "xsdk: available application templates" ;
      ECHO [ SHELL "\"$(.root)/bin/xsct\" -nodisp -eval \"puts [repo -apps]\"" ] ;
      ECHO "xsdk: available operating systems" ;
      ECHO [ SHELL "\"$(.root)/bin/xsct\" -nodisp -eval \"puts [repo -os]\"" ] ;
      ECHO "xsdk: available libraries" ;
      ECHO [ SHELL "\"$(.root)/bin/xsct\" -nodisp -eval \"puts [repo -libs]\"" ] ;
      ECHO "xsdk: available drivers" ;
      ECHO [ SHELL "\"$(.root)/bin/xsct\" -nodisp -eval \"puts [repo -drivers]\"" ] ;
    }

    toolset.flags xsdk .xsct $(condition) : $(.root)/bin/xsct ;
  }
  else
  {
    ECHO "xsdk:warning: unsupported operating system" os.name ;
  }
}

# Return XSDK root directory.
rule root ( )
{
  return $(.root) ;
}

# Return XSDK version.
rule version ( )
{
  return $(.version) ;
}

# A generator to create an XSDK Workspace.
class ws-generator : generator
{
  import regex ;
  import string ;
  import errors ;
  import assert ;

  # Initialize.
  rule __init__ ( id composing ? : source-types + : target-types-and-names + : requirements * )
  {
    generator.__init__ $(id) $(composing) : $(source-types) : $(target-types-and-names) : $(requirements) ;
  }

  # Add usage-requirements and targets generated by the XSDK
  # Workspace.
  rule run ( project name ? : property-set : sources * )
  {
    assert.equal [ sequence.length $(sources) ] : 1 ;

    property-set = [ $(property-set).add-raw <relevant>toolset ] ;
    property-set = [ $(property-set).add-raw <relevant>xsdk-processor-prefix ] ;
    property-set = [ $(property-set).add-raw <relevant>xsdk-processor-id ] ;
    property-set = [ $(property-set).add-raw <relevant>target-os ] ;
    property-set = [ $(property-set).add-raw <relevant>link ] ;
    property-set = [ $(property-set).add-raw <relevant>architecture ] ;
    property-set = [ $(property-set).add-raw <relevant>instruction-set ] ;
    property-set = [ $(property-set).add-raw <relevant>optimization ] ;
    property-set = [ $(property-set).add-raw <relevant>profiling ] ;
    property-set = [ $(property-set).add-raw <relevant>debug-symbols ] ;
    property-set = [ $(property-set).add-raw <relevant>runtime-debugging ] ;
    property-set = [ $(property-set).add-raw <relevant>inlining ] ;
    property-set = [ $(property-set).add-raw <relevant>define ] ;
    property-set = [ $(property-set).add-raw <relevant>include ] ;
    property-set = [ $(property-set).add-raw <relevant>library-path ] ;
    property-set = [ $(property-set).add-raw <relevant>cflags ] ;
    property-set = [ $(property-set).add-raw <relevant>linkflags ] ;

    if ! [ $(property-set).get <instruction-set> ]
    {
      errors.error "<instruction-set> must be set" ;
    }

    local xsdk-os = [ target-os-to-xsdk [ $(property-set).get <target-os> ] ] ;
    if ! $(xsdk-os)
    {
      errors.error "unsupported <target-os> " [ $(property-set).get <target-os> ] ;
    }
    property-set = [ $(property-set).add-raw <xsdk-os>$(xsdk-os) ] ;

    local xsdk-instruction-set = [ instruction-set-to-xsdk [ $(property-set).get <instruction-set> ] ] ;
    if ! $(xsdk-instruction-set)
    {
      errors.error "unsupported <instruction-set> " [ $(property-set).get <instruction-set> ] ;
    }
    property-set = [ $(property-set).add-raw <xsdk-instruction-set>$(xsdk-instruction-set) ] ;

    local xsdk-processor-prefix = [ $(property-set).get <xsdk-processor-prefix> ] ;
    if ! $(xsdk-processor-prefix)
    {
      xsdk-processor-prefix = [ instruction-set-to-prefix [ $(property-set).get <instruction-set> ] ] ;

      property-set = [ $(property-set).add-raw <xsdk-processor-prefix>$(xsdk-processor-prefix) ] ;
    }
    local xsdk-processor-id = [ $(property-set).get <xsdk-processor-id> ] ;

    assert.variable-not-empty xsdk-processor-prefix ;
    assert.variable-not-empty xsdk-processor-id ;

    local r = [ generator.run $(project) $(name) : $(property-set) : $(sources) ] ;

    local ps ;
    local vts ;

    if [ class.is-a $(r[1]) : property-set ]
    {
      ps = $(r[1]) ;
      vts = $(r[2-]) ;
    }
    else
    {
      vts = $(r) ;
    }

    local ws-dir ;
    for local vt in $(vts)
    {
      if [ $(vt).type ] = XSDKWS
      {
        local p = [ $(vt).path ] ;
        local n = [ $(vt).name ] ;

        ws-dir = $(p)/$(n) ;
      }
    }

    assert.variable-not-empty ws-dir ;

    # add properties from createhw

    ps = [ $(ps).add-raw <include>$(ws-dir)/hw ] ;

    local instruction-set = [ $(property-set).get <instruction-set> ] ;

    switch [ regex.match "([^+]+)" : $(instruction-set) : 0 ]
    {
      case cortex-a9 :
          ps = [ $(ps).add-raw <linkflags>"-Wl,-build-id=none" ] ;
          ps = [ $(ps).add-raw <linkflags>-specs="$(ws-dir)/app/src/Xilinx.spec" ] ;
    }

### @todo workaround for linking issues
###    for local vt in $(vts)
###    {
###      if [ type.is-derived [ $(vt).type ] LIB ]
###      {
###        local s = [ $(vt).search ] ;
###
###        ps = [ $(ps).add-raw <include>$(s:D)/include ] ;
###      }
###    }
    local bsp-dir = $(ws-dir)/bsp/$(xsdk-processor-prefix)_$(xsdk-instruction-set)_$(xsdk-processor-id) ;

    ps = [ $(ps).add-raw <include>$(bsp-dir)/include ] ;

    ps = [ $(ps).add-raw <library-path>$(bsp-dir)/lib ] ;

    {
      local bsp-libraries = xil ;
      if [ $(property-set).get <target-os> ] = freertos
      {
        bsp-libraries += freertos ;
      }
      for local l in [ $(property-set).get <xsdk-library> ]
      {
        bsp-libraries += [ xsdk-library-to-library $(l) ] ;
      }

### @todo workaround for linking issues
###      ps = [ $(ps).add-raw <include>$(s:D)/include ] ;
      # @todo this should be done with the right requirements on the libraries
      # all -> xil
      # openamp -> metal
      for local l in $(bsp-libraries)
      {
        local extra-libs ;
        if $(l) != xil
        {
          extra-libs += xil ;
        }
        if $(l) = open_amp
        {
          extra-libs += metal ;
        }
        local library-group = $(extra-libs) $(l) gcc c ;
        local linkflags = [ string.join -Wl --start-group -l$(library-group) --end-group : "," ] ;

        ps = [ $(ps).add-raw <linkflags>$(linkflags) ] ;
      }
    }

    # add properties from createapp

    local defines = [ instruction-set-to-defines $(instruction-set) ] ;

    ps = [ $(ps).add-raw <define>$(defines) ] ;

    ps = [ $(ps).add-raw <library-path>$(ws-dir)/app/src ] ;

    return $(ps) $(vts) ;
  }

  # Generate all the targets created by the XSDK.
  rule generated-targets ( sources + : property-set : project name ? )
  {
    assert.equal [ sequence.length $(sources) ] : 1 ;

    local virtual-targets ;

    local hdf-path = [ $(sources[1]).name ] ;
    local hdf-name = $(hdf-path:B) ;

    if ! $(name)
    {
      name = $(hdf-name) ;
    }

    local shared ;
    if [ $(property-set).get <link> ] = shared
    {
      shared = true ;
    }

    local xsdk-instruction-set = [ $(property-set).get <xsdk-instruction-set> ] ;
    local xsdk-processor-prefix = [ $(property-set).get <xsdk-processor-prefix> ] ;
    local xsdk-processor-id = [ $(property-set).get <xsdk-processor-id> ] ;

    assert.variable-not-empty xsdk-instruction-set ;
    assert.variable-not-empty xsdk-processor-prefix ;
    assert.variable-not-empty xsdk-processor-id ;

    local xsct-target ;
    {
      local a = [ class.new action $(sources) : xsdk.generate-build : $(property-set) ] ;
      local t = [ class.new file-target $(name) : XSCT : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;

      xsct-target = $(t) ;
    }

    local a = [ class.new action $(xsct-target) $(sources) : xsdk.generate-ws : $(property-set) ] ;

    local xsdkws-target ;
    local xsctrun-target ;
    {
      local t ;

      t = [ class.new file-target $(name) : XSDKWS : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;

      xsdkws-target = $(t) ;

      t = [ class.new file-target $(name) : XSCTRUN : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;

      xsctrun-target = $(t) ;
    }

    {
      local a = [ class.new action $(xsctrun-target) $(sources) : xsdk.generate-run : $(property-set) ] ;
      local t = [ class.new file-target run : TCL : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    # targets generated by createhw

    local t ;

    local build-dir = [ $(xsdkws-target).path ] ;
    local ws = [ $(xsdkws-target).name ] ;

    local bsp-dir = $(build-dir)/$(ws)/bsp/$(xsdk-processor-prefix)_$(xsdk-instruction-set)_$(xsdk-processor-id) ;

    assert.variable-not-empty bsp-dir ;

    t = [ class.new file-target $(ws)/hw/system : HDF : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    if $(hdf-name) = system
    {
      t = [ class.new file-target $(ws)/hw/design_1_wrapper : BIT : $(project) : $(a) ] ;
    }
    else
    {
      t = [ class.new file-target $(ws)/hw/$(hdf-name)_cfg : BIT : $(project) : $(a) ] ;
    }
    virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target $(ws)/hw/$(xsdk-processor-prefix)_init : TCL : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

### @todo workaround to allow tighter control of linking
###    t = [ class.new file-target $(ws)/hw/$(xsdk-processor-prefix)_init : H : $(project) : $(a)  ] ;
###    virtual-targets += [ virtual-target.register $(t) ] ;
###    t = [ class.new file-target $(ws)/hw/$(xsdk-processor-prefix)_init_gpl : H : $(project) : $(a)  ] ;
###    virtual-targets += [ virtual-target.register $(t) ] ;
    # @todo this should not be linked in except in very specific circumstances
    # t = [ class.new file-target $(ws)/hw/$(xsdk-processor-prefix)_init : C : $(project) : $(a)  ] ;
    # virtual-targets += [ virtual-target.register $(t) ] ;
    # @todo this duplicates whats in $(xsdk-processor-prefix)_init for some reason, which one is the right one?
    # t = [ class.new file-target $(ws)/hw/$(xsdk-processor-prefix)_init_gpl : C : $(project) : $(a)  ] ;
    # virtual-targets += [ virtual-target.register $(t) ] ;

    # targets generated by createbsp

    t = [ class.new file-target $(ws)/bsp/system : MSS : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

### @todo workaround to allow tighter control of linking
###    for local l in [ $(property-set).get <xsdk-library> ]
###    {
###      local translated-l = [ xsdk-library-to-library $(l) ] ;
###
###      t = [ class.new searched-lib-target $(translated-l) : $(project) : $(shared) : $(bsp-dir)/lib : $(a) ] ;
###      virtual-targets += [ virtual-target.register $(t) ] ;
###    }
###
###    if [ $(property-set).get <target-os> ] = freertos
###    {
###      t = [ class.new searched-lib-target freertos : $(project) : $(shared) : $(bsp-dir)/lib : $(a) ] ;
###      virtual-targets += [ virtual-target.register $(t) ] ;
###    }
###
###    t = [ class.new searched-lib-target xil : $(project) : $(shared) : $(bsp-dir)/lib : $(a) ] ;
###    virtual-targets += [ virtual-target.register $(t) ] ;

    return $(virtual-targets) ;
  }

  # Return the name of the XSDK operating system indicated by the
  # <target-os> represented by value.
  rule target-os-to-xsdk ( value )
  {
    assert.in $(value) : [ feature.values <target-os> ] ;

    local tmp ;
    switch $(value)
    {
      case elf : tmp = standalone ;
      case freertos : tmp = freertos10_xilinx ;
      case xilkernel : tmp = xilkernel ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }

  # Return the name of the XSDK processor, which is the same as an
  # instruction set, indicated by the <instruction-set> represented by
  # value.
  rule instruction-set-to-xsdk ( value )
  {
    assert.in $(value) : [ feature.values <instruction-set> ] ;

    local tmp ;
    switch [ regex.match "([^+]+)" : $(value) : 0 ]
    {
      case cortex-a9 : tmp = cortexa9 ;
      case cortex-a53 : tmp = cortexa53 ;
      case cortex-r5 : tmp = cortexr5 ;
      case microblaze : tmp = microblaze ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }

  # Return the prefix used in the path to the processor in the
  # board-support package.
  rule instruction-set-to-prefix ( value )
  {
    assert.in $(value) : [ feature.values <instruction-set> ] ;

    local tmp ;
    switch [ regex.match "([^+]+)" : $(value) : 0 ]
    {
      case cortex-a9 : tmp = ps7 ;
      case cortex-a53 : tmp = psu ;
      case cortex-r5 : tmp = psu ;
      case microblaze : tmp = psu ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }

  # Return the preprocessor definitions required by the
  # <instruction-set> represented by value.
  rule instruction-set-to-defines ( value )
  {
    assert.in $(value) : [ feature.values <instruction-set> ] ;

    local tmp ;
    switch [ regex.match "([^+]+)" : $(value) : 0 ]
    {
      case cortex-r5 : tmp += ARMR5 ;
    }

    return $(tmp) ;
  }

  # Return the <library> as required by the <xsdk-library> represented
  # by value.
  #
  # The <xsdk-library> names within the XSDK are not the same as the
  # filenames produced by the XSDK.
  rule xsdk-library-to-library ( value )
  {
    local tmp = $(value) ;
    switch $(tmp)
    {
      case libmetal : tmp = metal ;
      case openamp : tmp = open_amp ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }
}

# @todo loop and generate many generators for each supported configuration?
generators.register [ class.new ws-generator xsdk.generate-ws-elf : HDF : XSDKWS XSCT XSCTRUN BIT MSS TCL : <toolset>gcc ] ;

# Generate an XSCT script to build the XSDK Workspace.
rule generate-build ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 1 ;

  local target = $(targets[1]) ;
  local source = $(sources[1]) ;
  local ws-dir = [ on $(target) return $(LOCATE) ] ;
  local ws-name = $(target:G=) ;
  local ws = $(ws-dir)/$(ws-name:S=.xsdkws) ;

  local hdf-dir = [ on $(source) return $(LOCATE) ] ;
  local hdf-name = $(source:G=) ;

  local hdf = $(hdf-dir)/$(hdf-name) ;
  if ! $(hdf)
  {
    hdf = $(hdf-name) ;
  }

  local xsdk-os = [ feature.get-values <xsdk-os> : $(properties) ] ;
  local xsdk-instruction-set = [ feature.get-values <xsdk-instruction-set> : $(properties) ] ;
  local xsdk-processor-prefix = [ feature.get-values <xsdk-processor-prefix> : $(properties) ] ;
  local xsdk-processor-id = [ feature.get-values <xsdk-processor-id> : $(properties) ] ;
  local xsdk-template = [ feature.get-values <xsdk-template> : $(properties) ] ;
  xsdk-template ?= "Empty Application" ;

  assert.variable-not-empty xsdk-os ;
  assert.variable-not-empty xsdk-instruction-set ;
  assert.variable-not-empty xsdk-processor-prefix ;
  assert.variable-not-empty xsdk-processor-id ;

  local lines ;

  lines += "# generated by xsdk.jam" ;

  lines +=
    "proc run-checked args {"
    "    set ss [uplevel 1 $args]"
    "    if {$ss != \"\"} then {"
    "        return -code error \"error: $ss\""
    "        exit 1"
    "    }"
    "}"
    ;

  # set the workspace
  lines += "run-checked setws -switch $(ws)" ;

  # channels to capture the configurations
  lines += "set possible_configuration [open $(ws)/../possible_configuration.txt w]" ;
  lines += "set original_configuration [open $(ws)/../original_configuration.txt w]" ;
  lines += "set actual_configuration [open $(ws)/../actual_configuration.txt w]" ;

  # create the hardware
  lines += "run-checked createhw -name hw -hwspec $(hdf)" ;

  # create and configure the bsp
  lines += "run-checked createbsp -name bsp -proc $(xsdk-processor-prefix)_$(xsdk-instruction-set)_$(xsdk-processor-id) -hwproject hw -os $(xsdk-os)" ;

  lines += "puts $possible_configuration \"bsp operating system:\n[configbsp -bsp bsp -os]\"" ;
  lines += "puts $possible_configuration \"bsp processor:\n[configbsp -bsp bsp -proc]\"" ;
  lines += "puts $possible_configuration \"bsp libraries:\n[getlib -bsp bsp]\"" ;

  for local l in [ feature.get-values <xsdk-library> : $(properties) ]
  {
    lines += "setlib -bsp bsp -lib $(l)" ;
  }
  for local c in [ feature.get-values <xsdk-configuration> : $(properties) ]
  {
    lines += "configbsp -bsp bsp $(c)" ;
  }

  lines += "puts $original_configuration \"bsp operating system:\n[configbsp -bsp bsp -os]\"" ;
  lines += "puts $original_configuration \"bsp processor:\n[configbsp -bsp bsp -proc]\"" ;
  lines += "puts $original_configuration \"bsp libraries:\n[getlib -bsp bsp]\"" ;
  for local l in [ feature.get-values <xsdk-library> : $(properties) ]
  {
    lines += "puts $original_configuration \"library $(l):\n[configbsp -bsp bsp -lib $(l)]\"" ;
  }

  # flags to track between desired build and BSP
  local interesting-compiler-flags =
    -mcpu
    -mfpu
    -mfloat-abi
    ;

  # remove all interesting compiler flags from BSP
  lines +=
    "set interesting_compiler_flags [list]"
    "lappend interesting_compiler_flags \"$(interesting-compiler-flags)\""
    "set compiler_flags [list]"
    "foreach word [split [configbsp -bsp bsp compiler_flags] \" \"] {"
    "    if {[lsearch -glob $interesting_compiler_flags $word=*] >= 0} then {"
    "        continue"
    "    }"
    "    lappend compiler_flags $word"
    "}"
    "configbsp -bsp bsp compiler_flags [join $compiler_flags \" \"]"
    "set extra_compiler_flags [list]"
    "foreach word [split [configbsp -bsp bsp extra_compiler_flags] \" \"] {"
    "    if {[lsearch -glob $interesting_compiler_flags $word=*] >= 0} then {"
    "        continue"
    "    }"
    "    lappend extra_compiler_flags $word"
    "}"
    "configbsp -bsp bsp extra_compiler_flags [join $extra_compiler_flags \" \"]"
    ;
  # check against standard features
  local bsp-fields = compiler_flags extra_compiler_flags ;
  # check also within <cflags> and <linkflags>
  for local t in [ feature.get-values <cflags> : $(properties) ]
  {
    local f = [ regex.match "(.+)[ =](.+)" : $(t) : 0 ] ;
    if $(f) in $(interesting-compiler-flags)
    {
      lines += "configbsp -bsp bsp -append $(bsp-fields) \"$(t)\"" ;
    }
  }
  for local t in [ feature.get-values <linkflags> : $(properties) ]
  {
    local f = [ regex.match "(.+)[ =](.+)" : $(t) : 0 ] ;
    if $(f) in $(interesting-compilerflags)
    {
      lines += "configbsp -bsp bsp -append $(bsp-fields) \"$(t)\"" ;
    }
  }

  # print the actual BSP configuration
  lines += "puts $actual_configuration \"bsp operating system:\n[configbsp -bsp bsp -os]\"" ;
  lines += "puts $actual_configuration \"bsp processor:\n[configbsp -bsp bsp -proc]\"" ;
  lines += "puts $actual_configuration \"bsp libraries:\n[getlib -bsp bsp]\"" ;
  for local l in [ feature.get-values <xsdk-library> : $(properties) ]
  {
    lines += "puts $actual_configuration \"library $(l):\n[configbsp -bsp bsp -lib $(l)]\"" ;
  }

  lines += "updatemss -mss $(ws)/bsp/system.mss" ;
  lines += "regenbsp -bsp bsp" ;

  # build the bsp
  lines += "run-checked projects -build -type bsp -name bsp" ;

  # create a dummy application for the linker file
  local empty-template = "Empty Application" ;
  local hello-template = "Hello World" ;
  if [ feature.get-values <target-os> ] = freertos
  {
    hello-template = "FreeRTOS Hello World" ;
  }

  lines += "run-checked createapp -name app -app {$(xsdk-template)} -lang c -bsp bsp -proc $(xsdk-processor-prefix)_$(xsdk-instruction-set)_$(xsdk-processor-id) -hwproject hw -os $(xsdk-os)" ;

  lines +=
    "foreach line [split [configapp] \"\n\"] {"
    "    regexp { *([^ ]+) .+ *} $line ignored option"
    "    puts $possible_configuration \"app app $option:\n[configapp -app app -info $option]\""
    "}"
    ;

  # print the original application configuration
  lines +=
    "foreach line [split [configapp] \"\n\"] {"
    "    regexp { *([^ ]+) .+ *} $line ignored option"
    "    puts $original_configuration \"app app $option: [configapp -app app $option]\""
    "}"
    ;

  # @todo compiler flags cannot be removed from application configration
  # # remove all interesting compiler flags from application
  # lines +=
  #   "set compiler_misc [list]"
  #   "foreach word [split [configapp -app app compiler-misc] \" \"] {"
  #   "    if {[lsearch -glob $interesting_compiler_flags $word=*] >= 0} then {"
  #   "        continue"
  #   "    }"
  #   "    lappend compiler_misc $word"
  #   "}"
  #   "configapp -app app -set compiler-misc [join $compiler_misc \" \"]"
  #   "set linker_misc [list]"
  #   "foreach word [split [configapp -app app linker-misc] \" \"] {"
  #   "    if {[lsearch -glob $interesting_compiler_flags $word=*] >= 0} then {"
  #   "        continue"
  #   "    }"
  #   "    lappend linker_misc $word"
  #   "}"
  #   "configapp -app app -set linker-misc [join $linker_misc \" \"]"
  #   ;
  local app-fields = compiler-misc linker-misc ;
  for local t in [ feature.get-values <cflags> : $(properties) ]
  {
    local f = [ regex.match "(.+)[ =](.+)" : $(t) : 0 ] ;
    if $(f) in $(interesting-compiler-flags)
    {
      lines += "configapp -app app -add $(app-fields) \"$(t)\"" ;
    }
  }
  for local t in [ feature.get-values <linkflags> : $(properties) ]
  {
    local f = [ regex.match "(.+)[ =](.+)" : $(t) : 0 ] ;
    if $(f) in $(interesting-compilerflags)
    {
      lines += "configapp -app app -add $(app-fields) \"$(t)\"" ;
    }
  }

  # print the actual application configuration
  lines +=
    "foreach line [split [configapp] \"\n\"] {"
    "    regexp { *([^ ]+) .+ *} $line ignored option"
    "    puts $actual_configuration \"app app $option: [configapp -app app $option]\""
    "}"
    ;

  lines += "close $possible_configuration" ;
  lines += "close $original_configuration" ;
  lines += "close $actual_configuration" ;

  print.output $(target) ;
  print.text "#!/usr/bin/env xsct" : true ;
  print.lines $(lines) ;
  print.text "" ;
}

# Generate an XSCT script to run a program built with the XSDK
# Workspace.
#
# @todo The generated run.tcl probably only works for the Cortex-R5.
# There is significant work to get it working for all possible
# targets.  The best approach (which may not be possible) would be to
# have the xsct tool generate the run.tcl file.
rule generate-run ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 2 ;

  local target = $(targets[1]) ;
  local xsctrun-source = $(sources[1]) ;
  local hdf-source = $(sources[2]) ;

  local ws-dir = [ on $(target) return $(LOCATE) ] ;
  local ws-name = $(xsctrun-source:G=) ;
  local ws = $(ws-dir)/$(ws-name:S=.xsdkws) ;
  local ws-absolute = [ path.root $(ws) [ path.pwd ] ] ;

  local fpga-name = $(hdf-source:B) ;

  local xsdk-os = [ feature.get-values <xsdk-os> : $(properties) ] ;
  local xsdk-instruction-set = [ feature.get-values <xsdk-instruction-set> : $(properties) ] ;
  local xsdk-processor-prefix = [ feature.get-values <xsdk-processor-prefix> : $(properties) ] ;
  local xsdk-processor-id = [ feature.get-values <xsdk-processor-id> : $(properties) ] ;
  local xsdk-template = [ feature.get-values <xsdk-template> : $(properties) ] ;
  xsdk-template ?= "Empty Application" ;

  assert.variable-not-empty xsdk-os ;
  assert.variable-not-empty xsdk-instruction-set ;
  assert.variable-not-empty xsdk-processor-prefix ;
  assert.variable-not-empty xsdk-processor-id ;

  local lines ;

  lines += "# generated by xsdk.jam" ;

  lines += "set xsdkroot [file normalize $(.root)]" ;

  # @todo check for errors

  # set the workspace
  lines +=
    "if {$argc != 1} then {"
    "    puts \"usage: $argv0 <program>\""
    "    exit 1"
    "}"
    ;

  lines +=
    "set program [file normalize [lindex $argv 0]]"

    "set ws [file normalize $(ws-absolute)]"

    "set hdf [file join $ws hw system.hdf]"
    "set bit [glob -directory [file join $ws hw] *_cfg.bit]"

    "set jtag_cable_name \"*\""

    "if {! [file exists $ws]} {"
    "    puts \"error: workspace $ws does not exist\""
    "    exit 1"
    "}"
    "setws -switch $ws"

    "connect"

    "source [file normalize [file join $xsdkroot scripts sdk util zynqmp_utils.tcl]]"

    # @todo below is RPU-specific, generalize using properties
    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "rst -system"
    "after 3000"

    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "reset_apu"

    "targets -set -nocase -filter {name =~ \"RPU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "clear_rpu_reset"
    "enable_split_mode"

    "targets -set -filter {jtag_cable_name =~ $jtag_cable_name && level==0} -index 0"
    "fpga -file $bit"

    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "loadhw -hw $hdf -mem-ranges [list {  0x80000000   0xbfffffff} { 0x400000000  0x5ffffffff} {0x1000000000 0x7fffffffff}]"

    "configparams force-mem-access 1"
    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"

    "source [file join $ws hw $(xsdk-processor-prefix)_init.tcl]"
    "after 3000"
    "$(xsdk-processor-prefix)_init"
    "source [file normalize [file join $xsdkroot scripts sdk util fsbl.tcl]]"
    "after 1000"
    "$(xsdk-processor-prefix)_ps_pl_isolation_removal"
    "after 1000"
    "$(xsdk-processor-prefix)_ps_pl_reset_config"
    "catch {$(xsdk-processor-prefix)_protection}"

    "targets -set -nocase -filter {name =~ \"*R5*0\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "rst -processor"
    "catch {XFsbl_TcmEccInit R5_0}"

    "dow $program"

    "bpadd -addr &main"

    "configparams force-mem-access 0"

    "con"
  ;

  print.output $(target) ;
  print.text "#!/usr/bin/env xsct" : true ;
  print.lines $(lines) ;
  print.text "" ;
}

actions generate-run
{
  echo chmod a+x $(<)
}

TOUCH = [ common.file-touch-command ] ;
if [ os.name ] = NT
{
  RMDIR = rmdir /s /q ;
}
else
{
  RMDIR = rm -rf ;
}

# Coupled with the actions of the same name, runs the script to build
# the XSDK Workspace.
rule generate-ws ( targets + : sources + : properties * )
{
#  assert.equal [ sequence.length $(targets) ] : 1 ;
#  assert.equal [ sequence.length $(sources) ] : 1 ;
}

actions generate-ws
{
  $(RMDIR) "$(<[1])" && "$(.xsct)" -nodisp "$(>[1])" && $(TOUCH) "$(<[2])"
}
