#|
Copyright 2019 Thomas Brown
Distributed under the Boost Software License, Version 1.0. (See
accompanying file LICENSE_1_0.txt or copy at
http://www.boost.org/LICENSE_1_0.txt)
|#

# Boost.Build support for the Xilinx SDK (XSDK).

#| tag::doc[]

= Xilinx SDK (XSDK) Reference Manual

The Xilnx Boost.Build module provides the `xsdk` tool.

== Configuration

[source, jam]
----
import xsdk ;
----

The XSDK tool must be configured as any other Boost.Build tool.  The
tool will automatically detect the location and version of the tool.

[source, jam]
----
using xsdk ;
----

The desired version can be specified.

[source, jam]
----
using xsdk : 2018.3 ;
----

The location can also be specified both with and without a desired
version.

[source, jam]
----
using xsdk : : /opt/Xilinx/SDK/2018.3 ;
----

Note that running with the `--debug-configuration` option to
Boost.Build will include the XSDK location and version as well as the
application templates, operating systems, libraries, and drivers
supported by the version of the tool configured.

== Main Target

This project will add one main target type named `xsdkws`.

----
xsdkws ( name : source : requirements * : default-build * : usage-requirements )
----

This target will place an application named `app`, a board-support
packaged named `bsp`, and a hardware definition named `hw` within a
workspace named as defined in the rule, `$(name)`, and provide
`usage-requirements` to users of the named target.

This target will also create several supporting XSCT scripts in the
build directory.  These script can run using XSCT.

The `print.tcl` script will print out all the available configuration
options for the XSDK Workspace.  This can be useful when developing
the configuration for a project.

The `run.tcl` script take the any compatible program file as an
argument and will run the program.  This script can be used with the
Boost.Build `testing` module as a `<testing.launcher>`.

This target works by creating and running an XSCT script containing
`xsct` commands with values translated from Boost.Build features such
as `<instruction-set>`, `<target-os>`, and others.  Some
representative examples of those `xsct` commands are below.

Create the workspace (`$(build-dir)/$(name).xsdkws`) from the
properties.

[source, tcl]
----
setws $(build-dir)/$(name).xsdkws
----

Generate the hardware definition (`hw`) from the hardware definition
file specified in `$(source)`.

[source, tcl]
----
createhw -name hw -hwspec $(source:G=)
----

Generate and build a board-support package (`bsp`) from the hardware
definition (`hw`), standard Boost.Build features, and free-form
configuration options.

[source, tcl]
----
createbsp -name bsp -proc $(xsdk-instruction-set) -hwproject hw -os $(xsdk-os-name)

configbsp -bsp bsp sleep_timer psu_ttc_3

updatemss -mss  $ws/bsp/system.mss
regenbsp -bsp bsp

projects -build -type bsp -name bsp
----

Generate and build an application (`app`) which provides a
linker-command file and some options required to properly build an
application.

Note that building the application is done as a reference to debug
build issues with programs not built using the XSCT tool.

[source, tcl]
----
createapp -name app -app {$(xsdk-template)} -lang $(xsdk-language) -bsp bsp -proc psu_$(xsdk-instruction-set)_$(xsdk-processor-id) -hwproject hw -os $(xsdk-os-name)

projects -build -type app -name app
----

== Suported FPGA

* Zynq UltraScale+ MPSoC
* Zynq 7000 SoC

== Toolsets

This module supports the processor-specific `gcc` toolsets delivered
within the Xilinx XSDK.

Note that in order to choose the correct toolset, the toolset should
be made conditional on the `instruction-set` in the build system.
One approach for doing this would be to set project requirements in
the Jamroot.  This is required because the `toolset` feature cannot
set in `usage-requirements`.

.`Jamroot`
[source, jam]
----
project
  : requirements
    <instruction-set>cortex-a9:<toolset>gcc-7xilinxaarch32
    <instruction-set>cortex-a53:<toolset>gcc-7xilinxaarch64

    <instruction-set>cortex-r5:<toolset>gcc-7xilinxarmr5

    <instruction-set>microblaze:<toolset>gcc-7xilinxmicroblaze
  ;
----

.`project-config.jam`
[source, jam]
----
using xsdk ;

local xsdk-root = [ xsdk.root ] ;

using gcc : 7xilinxaarch32 : $(xsdk-root)/gnu/aarch32/lin/gcc-arm-none-eabi/bin/arm-none-eabi-g++ ;
using gcc : 7xilinxaarch64 : $(xsdk-root)/gnu/aarch64/lin/aarch64-none/bin/aarch64-none-elf-g++ ;

using gcc : 7xilinxarmr5 : $(xsdk-root)/gnu/armr5/lin/gcc-arm-none-eabi/bin/armr5-none-eabi-g++ ;

using gcc : 7xilinxmicroblaze : $(xsdk-root)/gnu/microblaze/lin/bin/microblaze-xilinx-elf-g++ ;
----

== Boost.Build Features

The following Boost.Build features are used to configure the XSDK.
Workspace.

If Boost.Build does not support a required value for a feature, the
`xsdk` tool will extend the feature with the additional values.

== `<target-os>` - the target operating system

* `elf` - The `standalone` Xilinx operating system.
* `freertos` - The FreeRTOS operating system.

== `<instruction-set>` - the instruction set or processor

* `cortex-a9` - Cortex-A9
* `cortex-a53` - Cortex-A53
* `cortex-r5` - Cortex-R5
* `microblaze` - Microblaze

== XSDK-related Features

Boost.Build will generally configure the board-support package given
Boost.Build features.  These features can be overridden using the
following toolset flags.

=== `xsdk-template`

This feature indicates the application template used to generate the
application.  The application provides the linker script used by
programs built with the XSDK Workspace.

The resulting files can be used to create or update the actual
application code, but are not used when generating programs from the
XSDK Workspace.

This defaults to an empty application.

=== `xsdk-configuration`

This feature provides information for configuring a board-support
package.  A configuration is a string added to the end of the call to
`configbsp`.

The system will generate the following for each
`<xsdk-configuration>STRING`.

[source, tcl]
----
configbps -bsp bsp STRING
----

=== `xsdk-library`

This feature adds Xilinx libraries to the board-support package.
These are the library names as described in the XSDK documentation.

=== `xsdk-processor-id`

This feature assigns an application to run on a particular processor
on the SoC, defaulting to 0.

|# # end::doc[]

import os ;
import path ;
import common ;
import print ;
import sequence ;
import errors ;
import assert ;

import toolset ;
import feature ;
import type ;
import "class" ;
import generators ;
import property-set ;

if [ MATCH (--debug-configuration) : [ modules.peek : ARGV ] ]
{
  .debug-configuration = true ;
}

feature.feature xsdk-template : : free ;
feature.feature xsdk-configuration : : optional free link-incompatible ;
feature.feature xsdk-library : : optional free ;

feature.feature xsdk-os
  : # values
    standalone
    freertos10_xilinx
  : # attributes
    propagated optional
  ;

# @todo until all target-os supported in Boost.Build
for local t in freertos
{
  local target-os-values = [ feature.values <target-os> ] ;
  if ! $(t) in $(target-os-values)
  {
    feature.extend target-os : $(t) ;
  }
}

# @todo until all architecture supported in Boost.Build
for local t in microblaze
{
  local architecture-values = [ feature.values <architecture> ] ;
  if ! $(t) in $(architecture-values)
  {
    feature.extend architecture : $(t) ;
  }
}

feature.feature xsdk-instruction-set
  : # values
    # arm
    cortexa9
    cortexa53
    cortexr5
  : # attributes
    propagated optional
  ;

# @todo until all instruction-set supported in Boost.Build
for local t in cortex-a9 cortex-a53 cortex-r5

{
  local instruction-set-values = [ feature.values <instruction-set> ] ;
  if ! $(t) in $(instruction-set-values)
  {
    feature.extend instruction-set : $(t) ;
  }
}

feature.feature xsdk-processor-id : 0 1 2 3 : link-incompatible ;
feature.set-default xsdk-processor-id : 0 ;

type.register XSDKWS : xsdkws ;

type.register HDF : hdf ;

type.register XSCT : xsct ;
type.register XSCTRUN : xsctrun ;

type.register MSS : mss ;
type.register BIT : bit ;
type.register TCL : tcl ;

rule init ( version ? : command * : options * )
{
  # Check that the host operating system is supported.  If it is not,
  # continue without configuring so we can still build targets that do
  # not need this toolset.
  if [ os.name ] = NT || [ os.name ] = CYGWIN || [ os.name ] = LINUX
  {
    command = [ common.get-invocation-command xsdk : xsct : $(command) ] ;

    if $(command)
    {
      local output-lines = [ SPLIT_BY_CHARACTERS [ SHELL "\"$(command)\" -eval \"puts [version]\"" ] : "\n" ] ;

      local detected-version-components = [ MATCH "xsct ([0-9][0-9][0-9][0-9]\\.[0-9])" : $(output-lines[1]) ] ;
      local detected-version = $(detected-version-components[1]) ;

      if ! $(detected-version)
      {
        errors.user-error "xsdk: no version detected" ;
      }

      if $(version)
      {
        if $(detected-version) != $(version)
        {
          errors.user-error "xsdk: detected version (" $(detected-version) ") does not match desired (" $(version) ")" ;
        }
      }

      if $(detected-version)
      {
        version = $(detected-version) ;
      }
    }
    else
    {
      errors.user-error "xsdk: xsct not found at" $(command) ;
    }

    root = [ common.get-absolute-tool-path $(command[-1]) ] ;
    root = [ path.make $(root:D) ] ;

    if $(.debug-configuration)
    {
      ECHO "xsdk: using xsdk" $(version) "at" $(root) ;

      ECHO "xsdk: available application templates" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -apps]\"" ] ;
      ECHO "xsdk: available operating systems" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -os]\"" ] ;
      ECHO "xsdk: available libraries" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -libs]\"" ] ;
      ECHO "xsdk: available drivers" ;
      ECHO [ SHELL "\"$(root)/bin/xsct\" -eval \"puts [repo -drivers]\"" ] ;
    }

    toolset.flags xsdk .xsct $(condition) : $(root)/bin/xsct ;
  }
  else
  {
    ECHO "xsdk: warning: unsupported operating system" os.name ;
  }
}

# Return XSDK root directory.
rule root ( )
{
  return $(root) ;
}

# Generator for an XSDK Workspace.
class ws-generator : generator
{
  import errors ;
  import assert ;

  rule __init__ ( id composing ? : source-types + : target-types-and-names + : requirements * )
  {
    generator.__init__ $(id) $(composing) : $(source-types) : $(target-types-and-names) : $(requirements) ;
  }

  rule run ( project name ? : property-set : sources * )
  {
    property-set = [ $(property-set).add-raw <relevant>toolset ] ;
    property-set = [ $(property-set).add-raw <relevant>target-os ] ;
    property-set = [ $(property-set).add-raw <relevant>link ] ;
    property-set = [ $(property-set).add-raw <relevant>instruction-set ] ;

    # @todo is dynamic linking possible
####    if [ $(property-set).get <link> ] != static
####    {
####      errors.error "<link> must be static" ;
####    }

    if ! [ $(property-set).get <instruction-set> ]
    {
      errors.error "<instruction-set> must be set" ;
    }

    local xsdk-os = [ target-os-to-xsdk [ $(property-set).get <target-os> ] ] ;
    if ! $(xsdk-os)
    {
      errors.error "unsupported <target-os> " [ $(property-set).get <target-os> ] ;
    }
    property-set = [ $(property-set).add-raw <xsdk-os>$(xsdk-os) ] ;

    local xsdk-instruction-set = [ instruction-set-to-xsdk [ $(property-set).get <instruction-set> ] ] ;
    if ! $(xsdk-instruction-set)
    {
      errors.error "unsupported <instruction-set> " [ $(property-set).get <instruction-set> ] ;
    }
    property-set = [ $(property-set).add-raw <xsdk-instruction-set>$(xsdk-instruction-set) ] ;

    local r = [ generator.run $(project) $(name) : $(property-set) : $(sources) ] ;

    local ps ;
    local vts ;

    if [ class.is-a $(r[1]) : property-set ]
    {
      ps = $(r[1]) ;
      vts = $(r[2-]) ;
    }
    else
    {
      vts = $(r) ;
    }

    local ws-dir ;
    for local vt in $(vts)
    {
      if [ $(vt).type ] = XSDKWS
      {
        local p = [ $(vt).path ] ;
        local n = [ $(vt).name ] ;

        ws-dir = $(p)/$(n) ;
      }
    }

    assert.variable-not-empty ws-dir ;

    # add properties from createhw

    ps = [ $(ps).add-raw <include>$(ws-dir)/hw ] ;

    local instruction-set = [ $(property-set).get <instruction-set> ] ;

    # @todo this cannot work due to toolset and usage-requirement
    # toolset = [ instruction-set-to-toolset $(instruction-set) ] ;
    # ps = [ $(ps).add-raw <toolset>$(toolset) ] ;

    # @todo these should be done in gcc.jam really
    # @todo support specific instruction-sets better
    ps = [ $(ps).add-raw <cflags>-mtune=$(instruction-set) ] ;
    switch $(instruction-set)
    {
      case cortex-r5 : ps = [ $(ps).add-raw <cflags>-mfpu=vfpv3-d16 ] ;
    }

    # add properties from createbsp

    for local vt in $(vts)
    {
      if [ type.is-derived [ $(vt).type ] LIB ]
      {
        local s = [ $(vt).search ] ;

        ps = [ $(ps).add-raw <include>$(s:D)/include ] ;
      }
    }

    # @todo should be in gcc when elf, freertos
    ps = [ $(ps).add-raw <linkflags>-lgcc ] ;
    ps = [ $(ps).add-raw <linkflags>-lc ] ;

    # add properties from createapp

    local defines = [ instruction-set-to-defines $(instruction-set) ] ;

    ps = [ $(ps).add-raw <define>$(defines) ] ;

    ps = [ $(ps).add-raw <linkflags>"-T $(ws-dir)/app/src/lscript.ld" ] ;

    return $(ps) $(vts) ;
  }

  rule generated-targets ( sources + : property-set : project name ? )
  {
    assert.equal [ sequence.length $(sources) ] : 1 ;

    local virtual-targets ;

    if ! $(name)
    {
      name = [ generator.determine-output-name $(sources[1]) ] ;
    }

    local shared ;
    if [ $(property-set).get <link> ] = shared
    {
      shared = true ;
    }

    local xsdk-instruction-set = [ $(property-set).get <xsdk-instruction-set> ] ;
    local xsdk-processor-id = [ $(property-set).get <xsdk-processor-id> ] ;

    assert.variable-not-empty xsdk-instruction-set ;
    assert.variable-not-empty xsdk-processor-id ;

    local xsct-target ;
    {
      local a = [ class.new action $(sources) : xsdk.generate-build : $(property-set) ] ;
      local t = [ class.new file-target $(name) : XSCT : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;

      xsct-target = $(t) ;
    }

    local xsctrun-target ;
    {
      local a = [ class.new action $(xsct-target) : xsdk.generate-ws : $(property-set) ] ;
      local t = [ class.new file-target $(name) : XSCTRUN : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;

      xsctrun-target = $(t) ;
    }

    {
      local a = [ class.new action $(xsctrun-target) $(sources) : xsdk.generate-run : $(property-set) ] ;
      local t = [ class.new file-target run : TCL : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    {
      local a = [ class.new action $(xsctrun-target) $(sources) : xsdk.generate-print : $(property-set) ] ;
      local t = [ class.new file-target print : TCL : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    local a = [ class.new action $(xsctrun-target) : xsdk.ws-complete : $(property-set) ] ;

    local xsdkws-target ;
    {
      local t = [ class.new file-target $(name) : XSDKWS : $(project) : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;

      xsdkws-target = $(t) ;
    }

    # targets generated by createhw

    local t ;

    local build-dir = [ $(xsdkws-target).path ] ;
    local ws = [ $(xsdkws-target).name ] ;

    local bsp-dir = $(build-dir)/$(ws)/bsp/psu_$(xsdk-instruction-set)_$(xsdk-processor-id) ;

    assert.variable-not-empty bsp-dir ;

    # @todo do not generate the HDF target since it might be circular
    #t = [ class.new file-target $(ws)/hw/system : HDF : $(project) : $(a) ] ;
    #virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target $(ws)/hw/system : BIT : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target $(ws)/hw/psu_init : TCL : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    t = [ class.new file-target $(ws)/hw/psu_init : H : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    t = [ class.new file-target $(ws)/hw/psu_init_gpl : H : $(project) : $(a)  ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;
    # @todo this should not be linked in except in very specific circumstances
    # t = [ class.new file-target $(ws)/hw/psu_init : C : $(project) : $(a)  ] ;
    # virtual-targets += [ virtual-target.register $(t) ] ;
    # @todo this duplicates whats in psu_init for some reason, which one is the right one?
    # t = [ class.new file-target $(ws)/hw/psu_init_gpl : C : $(project) : $(a)  ] ;
    # virtual-targets += [ virtual-target.register $(t) ] ;

    # targets generated by createbsp

    t = [ class.new file-target $(ws)/bsp/system : MSS : $(project) : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    for local l in [ $(property-set).get <xsdk-library> ]
    {
      local translated-l = [ xsdk-library-to-library $(l) ] ;

      t = [ class.new searched-lib-target $(translated-l) : $(project) : $(shared) : $(bsp-dir)/lib : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    if [ $(property-set).get <target-os> ] = freertos
    {
      t = [ class.new searched-lib-target freertos : $(project) : $(shared) : $(bsp-dir)/lib : $(a) ] ;
      virtual-targets += [ virtual-target.register $(t) ] ;
    }

    t = [ class.new searched-lib-target xil : $(project) : $(shared) : $(bsp-dir)/lib : $(a) ] ;
    virtual-targets += [ virtual-target.register $(t) ] ;

    return $(virtual-targets) ;
  }

  # Return the name of the XSDK operating system indicated by the
  # <target-os> represented by value.
  local rule target-os-to-xsdk ( value )
  {
    assert.in $(value) : [ feature.values <target-os> ] ;

    local tmp ;
    switch $(value)
    {
      case elf : tmp = standalone ;
      case freertos : tmp = freertos10_xilinx ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }

  # Return the name of the XSDK processor, which is the same as an
  # instruction set, indicated by the <instruction-set> represented by
  # value.
  local rule instruction-set-to-xsdk ( value )
  {
    assert.in $(value) : [ feature.values <instruction-set> ] ;

    local tmp ;
    switch $(value)
    {
      case cortex-a9 : tmp = cortexa9 ;
      case cortex-a53 : tmp = cortexa53 ;
      case cortex-r5 : tmp = cortexr5 ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }

  # Return the preprocessor definitions required by the
  # <instruction-set> represented by value.
  local rule instruction-set-to-defines ( value )
  {
    assert.in $(value) : [ feature.values <instruction-set> ] ;

    local tmp ;
    switch $(value)
    {
      case cortex-r5 : tmp += ARMR5 ;
    }

    return $(tmp) ;
  }

  # Return the XSDK <toolset> as required by the <instruction-set>
  # represented by value.
  #
  # @todo this should take into account the XSDK version.
  local rule instruction-set-to-toolset ( value )
  {
    assert.in $(value) : [ feature.values <instruction-set> ] ;

    local tmp ;
    switch $(value)
    {
      case cortex-r5 : tmp = gcc-7xilinxarmr5 ;
      case cortex-a53 : tmp = gcc-7xilinxaarch64 ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }

  # Return the <library> as required by the <xsdk-library> represented
  # by value.
  #
  # The <xsdk-library> names within the XSDK are not the same as the
  # filenames produced by the XSDK.
  local rule xsdk-library-to-library ( value )
  {
    local tmp = $(value) ;
    switch $(tmp)
    {
      case libmetal : tmp = metal ;
      case openamp : tmp = open_amp ;
    }

    assert.variable-not-empty tmp ;

    return $(tmp) ;
  }
}

# @todo loop and generate many generators for each supported configuration?
generators.register [ class.new ws-generator xsdk.generate-ws-elf : HDF : XSDKWS XSCT XSCTRUN H LIB BIT MSS TCL : <toolset>gcc <link>static ] ;

# Generate an XSCT script to build the XSDK Workspace.
rule generate-build ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 1 ;

  local target = $(targets[1]) ;
  local source = $(sources[1]) ;
  local ws-dir = [ on $(target) return $(LOCATE) ] ;
  local ws-name = $(target:G=) ;
  local ws = $(ws-dir)/$(ws-name:S=.xsdkws) ;

  local hdf = $(source:G=) ;

  local xsdk-os = [ feature.get-values <xsdk-os> : $(properties) ] ;
  local xsdk-instruction-set = [ feature.get-values <xsdk-instruction-set> : $(properties) ] ;
  local xsdk-processor-id = [ feature.get-values <xsdk-processor-id> : $(properties) ] ;
  local xsdk-template = [ feature.get-values <xsdk-template> : $(properties) ] ;
  xsdk-template ?= "Empty Application" ;

  assert.variable-not-empty xsdk-os ;
  assert.variable-not-empty xsdk-instruction-set ;
  assert.variable-not-empty xsdk-processor-id ;

  local lines ;

  lines += "# generated by xsdk.jam" ;

  lines +=
    "proc run-checked args {"
    "    set ss [uplevel 1 $args]"
    "    if {$ss != \"\"} then {"
    "        return -code error \"error: $ss\""
    "        exit 1"
    "    }"
    "}"
    ;

  # set the workspace
  lines += "run-checked setws -switch $(ws)" ;

  # create the hardware
  lines += "run-checked createhw -name hw -hwspec $(hdf)" ;

  # create and configure the bsp
  # @todo print out all available options nicely
  lines += "run-checked createbsp -name bsp -proc psu_$(xsdk-instruction-set)_$(xsdk-processor-id) -hwproject hw -os $(xsdk-os)" ;
  for local l in [ feature.get-values <xsdk-library> : $(properties) ]
  {
    # @todo print out all available options nicely
    # @todo check for errors
    lines += "setlib -bsp bsp -lib $(l)" ;
  }
  # @todo print out all available options nicely
  for local c in [ feature.get-values <xsdk-configuration> : $(properties) ]
  {
    # @todo check for errors
    # @todo print out all available options nicely
    lines += "configbsp -bsp bsp $(c)" ;
  }

  lines += "updatemss -mss $(ws)/bsp/system.mss" ;
  lines += "regenbsp -bsp bsp" ;

  # create a dummy application for the linker file
  lines += "run-checked createapp -name app -app {$(xsdk-template)} -lang c -bsp bsp -proc psu_$(xsdk-instruction-set)_$(xsdk-processor-id) -hwproject hw -os $(xsdk-os)" ;

  # build the bsp
  lines += "run-checked projects -build -type bsp -name bsp" ;

  # build the application
  # @todo check for errors
  lines += "run-checked projects -build -type app -name app" ;

  print.output $(target) ;
  print.text "#!/usr/bin/env xsct" : true ;
  print.lines $(lines) ;
  print.text "" ;
}

# Generate an XSCT script to print the current and available
# configurations options of an XSDK Workspace.
rule generate-print ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 2 ;

  local target = $(targets[1]) ;
  local xsctrun-source = $(sources[1]) ;
  local hdf-source = $(sources[2]) ;

  local ws-dir = [ on $(target) return $(LOCATE) ] ;
  local ws-name = $(xsctrun-source:G=) ;
  local ws = $(ws-dir)/$(ws-name:S=.xsdkws) ;
  local ws-absolute = [ path.root $(ws) [ path.pwd ] ] ;

  local fpga-name = $(hdf-source:B) ;

  local lines ;

  lines += "# generated by xsdk.jam" ;

  lines +=
    "proc run-checked args {"
    "    set ss [uplevel 1 $args]"
    "    if {$ss != \"\"} then {"
    "        return -code error \"error: $ss\""
    "        exit 1"
    "    }"
    "}"
    ;

  # set the workspace
  lines += "run-checked setws -switch $(ws-absolute)" ;

  # repo
  # @todo do a regexp-based parse
  lines +=
    "# repo"
    "### set applications [list]"
    "### foreach line [lrange [split [repo -apps] \"\\n\"] 3 end] {"
    "###     if {[scan $line \"%s%s\" name processor operating_system] != 3} then {"
    "###         continue"
    "###     }"
    "###"
    "###     lappend applications $name"
    "### }"
    "puts \"[repo -apps]\""

    "set operating_systems [list]"
    "foreach line [lrange [split [repo -os] \"\\n\"] 3 end] {"
    "    if {[scan $line \"%s%s%s\" name version processor] != 3} then {"
    "        continue"
    "    }"

    "    lappend operating_systems $name"
    "}"
    "puts \"operating_systems: $operating_systems\""

    "set libraries [list]"
    "foreach line [lrange [split [repo -libs] \"\\n\"] 3 end] {"
    "    if {[scan $line \"%s%s\" name version] != 2} then {"
    "        continue"
    "    }"

    "    lappend libraries $name"
    "}"
    "puts \"libraries: $libraries\""

    "# @todo do a regexp-based parse"
    "puts \"[repo -drivers]\""
    ;

  # app
  lines +=
    "# app"
    "puts \"assembler-flags : [configapp -app app -info assembler-flags]\""
    "puts \"build-config : [configapp -app app -info build-config]\""
    "puts \"compiler-misc : [configapp -app app -info compiler-misc]\""
    "puts \"compiler-optimization : [configapp -app app -info compiler-optimization]\""
    "puts \"define-compiler-symbols : [configapp -app app -info define-compiler-symbols]\""
    "puts \"include-path : [configapp -app app -info include-path]\""
    "puts \"libraries : [configapp -app app -info libraries]\""
    "puts \"library-search-path : [configapp -app app -info library-search-path]\""
    "puts \"linker-misc : [configapp -app app -info linker-misc]\""
    "puts \"linker-script : [configapp -app app -info linker-script]\""
    "puts \"undef-compiler-symbols : [configapp -app app -info undef-compiler-symbols]\""

    "puts \"assembler-flags : [configapp -app app assembler-flags]\""
    "puts \"build-config : [configapp -app app build-config]\""
    "puts \"compiler-misc : [configapp -app app compiler-misc]\""
    "puts \"compiler-optimization : [configapp -app app compiler-optimization]\""
    "puts \"define-compiler-symbols : [configapp -app app define-compiler-symbols]\""
    "puts \"include-path : [configapp -app app include-path]\""
    "puts \"libraries : [configapp -app app libraries]\""
    "puts \"library-search-path : [configapp -app app library-search-path]\""
    "puts \"linker-misc : [configapp -app app linker-misc]\""
    "puts \"linker-script : [configapp -app app linker-script]\""
    "puts \"undef-compiler-symbols : [configapp -app app undef-compiler-symbols]\""
    ;

  # bsp
  lines +=
    "# bsp"
    "puts \"[getos -bsp bsp]\""
    "set os_parameters [list]"
    "foreach line [lrange [split [configbsp -bsp bsp -os] \"\\n\"] 3 end] {"
    "    if {[scan $line \"%s%s\" name value] != 2} then {"
    "        continue"
    "    }"

    "    lappend os_parameters $name"
    "}"
    "puts \"os_parameters: $os_parameters\""
    "set archiver [configbsp -bsp bsp archiver]"
    "set processor_parameters [list]"
    "foreach line [lrange [split [configbsp -bsp bsp -proc] \"\\n\"] 3 end] {"
    "    if {[scan $line \"%s%s\" name value] != 2} then {"
    "        continue"
    "    }"
    "    lappend processor_parameters $name"
    "}"
    "puts \"processor_parameters: $processor_parameters\""
    "foreach p $processor_parameters {"
    "    set value [configbsp -bsp bsp $p]"
    "    puts \"$p: $value\""
    "}"
    "set libraries [list]"
    "foreach line [lrange [split [getlibs -bsp bsp] \"\\n\"] 3 end] {"
    "    if {[scan $line \"%s%s\" name version] != 2} then {"
    "        continue"
    "    }"

    "    lappend libraries $name"
    "}"
    "foreach library $libraries {"
    "    set parameters [list]"
    "    foreach line [lrange [split [configbsp -bsp bsp -lib $library] \"\\n\"] 3 end] {"
    "        if {[scan $line \"%s%s\" name value] != 2} then {"
    "            continue"
    "        }"

    "        lappend parameters $name"
    "    }"

    "    puts \"library $library parameters: $parameters\""
    "}"

    "puts \"[getdrivers -bsp bsp]\""
    ;

  # hw
  lines +=
    "# hw"
    "# @todo is there anything here"
    ;

  print.output $(target) ;
  print.text "#!/usr/bin/env xsct" : true ;
  print.lines $(lines) ;
  print.text "" ;
}

# Generate an XSCT script to run a program built with the XSDK
# Workspace.
rule generate-run ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 2 ;

  local target = $(targets[1]) ;
  local xsctrun-source = $(sources[1]) ;
  local hdf-source = $(sources[2]) ;

  local ws-dir = [ on $(target) return $(LOCATE) ] ;
  local ws-name = $(xsctrun-source:G=) ;
  local ws = $(ws-dir)/$(ws-name:S=.xsdkws) ;
  local ws-absolute = [ path.root $(ws) [ path.pwd ] ] ;

  local fpga-name = $(hdf-source:B) ;

  local lines ;

  lines += "# generated by xsdk.jam" ;

  lines += "set xsdkroot [file normalize $(root)]" ;

  # @todo check for errors

  # set the workspace
  lines +=
    "if {$argc != 1} then {"
    "    puts \"usage: $argv0 <program>\""
    "    exit 1"
    "}"
    ;

  lines +=
    "set program [file normalize [lindex argv 0]"

    "set ws [file normalize $(ws-absolute)]"

    "set hdf [file normalize [file join $ws system.hdf]]"
    "set bit [file normalize [file join $ws $(fpga-name:S=.bit)]]]"

    "set jtag_cable_name \"*\""

    "if {! [file exists $ws]} {"
    "    puts \"error: workspace $ws does not exist\""
    "    exit 1"
    "}"
    "setws -switch $ws"

    "connect"

    "source [file normalize [file join $xsdkroot scripts sdk util zynqmp_utils.tcl]]"

    # @todo below is RPU-specific, generalize using properties
    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "rst -system"
    "after 3000"

    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "reset_apu"

    "targets -set -nocase -filter {name =~ \"RPU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "clear_rpu_reset"
    "enable_split_mode"

    "targets -set -filter {jtag_cable_name =~ $jtag_cable_name && level==0} -index 0"
    "fpga -file $bit"

    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "loadhw -hw $hdf -mem-ranges [list {  0x80000000   0xbfffffff} { 0x400000000  0x5ffffffff} {0x1000000000 0x7fffffffff}]"

    "configparams force-mem-access 1"
    "targets -set -nocase -filter {name =~ \"APU*\" && jtag_cable_name =~ $jtag_cable_name} -index 1"

    "source [file join $ws hw psu_init.tcl]"
    "after 3000"
    "psu_init"
    "source [file normalize [file join $xsdkroot scripts sdk util fsbl.tcl]]"
    "after 1000"
    "psu_ps_pl_isolation_removal"
    "after 1000"
    "psu_ps_pl_reset_config"
    "catch {psu_protection}"

    "targets -set -nocase -filter {name =~ \"*R5*0\" && jtag_cable_name =~ $jtag_cable_name} -index 1"
    "rst -processor"
    "catch {XFsbl_TcmEccInit R5_0}"

    "dow $program"

    "bpadd -addr &main"

    "configparams force-mem-access 0"

    "con"
  ;

  print.output $(target) ;
  print.text "#!/usr/bin/env xsct" : true ;
  print.lines $(lines) ;
  print.text "" ;
}

TOUCH = [ common.file-touch-command ] ;
if [ os.name ] = NT
{
  RMDIR = rmdir /s /q ;
}
else
{
  RMDIR = rm -rf ;
}

# Coupled with the actions of the same name, runs the script to build
# the XSDK Workspace.
rule generate-ws ( targets + : sources + : properties * )
{
  assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 1 ;
}

actions generate-ws
{
  $(RMDIR) $(<[1]:S=.xsdkws) && "$(.xsct)" "$(>[1])" && $(TOUCH) "$(<[1])"
}

# Generates the targets contained in the XSDK Workspace.
rule ws-complete ( targets + : sources + : properties * )
{
  # assert.equal [ sequence.length $(targets) ] : 1 ;
  assert.equal [ sequence.length $(sources) ] : 1 ;
}
